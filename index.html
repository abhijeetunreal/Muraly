<!DOCTYPE html>
<html lang="en">
<head>

<!-- Primary Meta Tags -->
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Muraly ‚Äî AR Mural Maker & Wall Visualization App</title>
<meta name="title" content="Muraly ‚Äî AR Mural Maker & Wall Visualization App" />
<meta name="description" content="Muraly is an augmented reality mural maker that lets you visualize wall art and murals in real spaces before painting or printing." />
<meta name="author" content="Codefrydev" />
<meta name="keywords" content="Muraly, AR mural maker, augmented reality wall art, mural visualization, AR design app, wall design, interior visualization" />
<meta name="robots" content="index, follow" />
<link rel="canonical" href="https://codefrydev.in/metatag/" />

<!-- Theme & Icons -->
<meta name="theme-color" content="#0ea5e9" />
<meta name="msapplication-TileColor" content="#0ea5e9" />
<link rel="icon" href="https://codefrydev.in/favicon-32x32.png" />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://codefrydev.in/metatag/" />
<meta property="og:title" content="Muraly ‚Äî Design & Preview Murals in AR" />
<meta property="og:description" content="Preview murals on real walls using augmented reality. Muraly helps artists and designers plan wall art with confidence." />
<meta property="og:image" content="https://codefrydev.in/images/IconCodefrydev.svg" />
<meta property="og:site_name" content="Muraly -AR Mural Maker & Wall Visualization App" />

<!-- Twitter -->
<meta name="twitter:card" content="Visualize murals and wall art in real spaces using AR. Create, preview, and design with Muraly." />
<meta name="twitter:title" content="Muraly ‚Äî Design & Preview Murals in AR" />
<meta name="twitter:description" content="Preview murals on real walls using augmented reality. Muraly helps artists and designers plan wall art with confidence." />
<meta name="twitter:image" content="https://codefrydev.in/images/IconCodefrydev.svg" />

<style>
:root { --glass: rgba(15,15,15,0.7); }

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  touch-action: none;
}

body {
  background: black;
  font-family: system-ui, sans-serif;
  overflow: hidden;
}

video, canvas {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
}

#camera { object-fit: cover; z-index: 1; }
#overlayCanvas { z-index: 2; }
#gridCanvas { z-index: 3; pointer-events: none; }

#panel {
  position: fixed;
  bottom: 14px;
  left: 50%;
  transform: translateX(-50%);
  width: calc(100% - 24px);
  max-width: 420px;
  background: var(--glass);
  backdrop-filter: blur(16px);
  border-radius: 18px;
  padding: 14px;
  color: white;
  z-index: 10;
}

#topBar {
  position: fixed;
  top: 12px;
  right: 12px;
  display: flex;
  gap: 10px;
  z-index: 10;
}

.iconBtn {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: var(--glass);
  backdrop-filter: blur(14px);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 18px;
}

.hidden { display: none !important; }

.row { display: flex; gap: 10px; margin-bottom: 10px; }
label { width: 70px; font-size: 12px; opacity: .7; }

input[type="range"], input[type="file"] { flex: 1; color: white; }

button {
  flex: 1;
  padding: 10px;
  border-radius: 10px;
  border: none;
  background: #222;
  color: white;
}

/* Viewer */
#remoteVideo {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  object-fit: contain;
  background: black;
  z-index: 999;
}
</style>
</head>


<body>

<!-- FIRST SCREEN: Host/Join selection -->
<div id="firstScreen" style="position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:black;z-index:1000;">
  <h2 style="color:white;margin-bottom:24px;">Welcome to AR Wall Drawing</h2>
  <div style="display:flex;gap:20px;">
    <button id="hostSelectBtn" style="padding:18px 36px;font-size:1.2em;">üì° Host</button>
    <button id="joinSelectBtn" style="padding:18px 36px;font-size:1.2em;">üîó Join</button>
  </div>
</div>

<!-- JOIN SCREEN: Enter key -->
<div id="joinScreen" class="hidden" style="position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:black;z-index:1000;">
  <h2 style="color:white;margin-bottom:18px;">Join a Session</h2>
  <input id="joinKeyInput" type="text" placeholder="Enter Share ID" style="padding:12px;font-size:1.1em;width:220px;margin-bottom:18px;">
  <button id="joinKeyBtn" style="padding:12px 28px;font-size:1.1em;">Join</button>
  <button id="backToFirstBtn" style="margin-top:18px;background:none;border:none;color:#aaa;">Back</button>
</div>

<!-- HOST AR -->
<video id="camera" autoplay playsinline></video>
<canvas id="overlayCanvas"></canvas>
<canvas id="gridCanvas"></canvas>

<div id="topBar">
  <div class="iconBtn" id="fullscreenBtn">‚õ∂</div>
</div>

<div id="panel">
  <div class="row">
    <label>Image</label>
    <input type="file" id="upload" accept="image/*">
  </div>

  <div class="row">
    <label>Opacity</label>
    <input type="range" id="opacity" min="0" max="1" step="0.01" value="0.6">
  </div>

  <div class="row">
    <button id="sketchBtn">‚úèÔ∏è Sketch</button>
    <button id="imageBtn">üñº Image</button>
  </div>

  <div class="row">
    <button id="lockBtn">üîì Move</button>
    <button id="gridBtn">Grid</button>
  </div>

  <hr style="opacity:.2">

  <div class="row">
    <button id="hostBtn">üì° Host</button>
    <button id="joinBtn">üîó Join</button>
  </div>

  <div id="shareId" style="font-size:12px;opacity:.7"></div>
</div>

<!-- VIEWER -->
<video id="remoteVideo" autoplay playsinline muted class="hidden"></video>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script>

// ================= APP MODE =================
let appMode = "host";
let renderActive = true;

/* ================= CAMERA ================= */

function startCamera() {
  navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" } })
    .then(s => camera.srcObject = s);
}
// ========== FIRST SCREEN LOGIC ==========
const firstScreen = document.getElementById("firstScreen");
const joinScreen = document.getElementById("joinScreen");
const hostSelectBtn = document.getElementById("hostSelectBtn");
const joinSelectBtn = document.getElementById("joinSelectBtn");
const joinKeyInput = document.getElementById("joinKeyInput");
const joinKeyBtn = document.getElementById("joinKeyBtn");
const backToFirstBtn = document.getElementById("backToFirstBtn");

function showHostScreen() {
  firstScreen.classList.add("hidden");
  joinScreen.classList.add("hidden");
  camera.classList.remove("hidden");
  overlayCanvas.classList.remove("hidden");
  gridCanvas.classList.remove("hidden");
  panel.classList.remove("hidden");
  topBar.classList.remove("hidden");
  startCamera();
  // Don't auto-start hosting, let user click Host button
}

function showJoinScreen() {
  firstScreen.classList.add("hidden");
  joinScreen.classList.remove("hidden");
  joinKeyInput.value = "";
  joinKeyInput.focus();
}

function doJoin() {
  const id = joinKeyInput.value.trim();
  if (!id) {
    joinKeyInput.focus();
    return;
  }
  joinScreen.classList.add("hidden");
  // Show host UI while waiting for stream
  camera.classList.remove("hidden");
  overlayCanvas.classList.remove("hidden");
  gridCanvas.classList.remove("hidden");
  panel.classList.remove("hidden");
  topBar.classList.remove("hidden");
  join(id);
}

hostSelectBtn.onclick = showHostScreen;
joinSelectBtn.onclick = showJoinScreen;
joinKeyBtn.onclick = doJoin;
joinKeyInput.addEventListener("keydown", e => { if (e.key === "Enter") doJoin(); });
backToFirstBtn.onclick = () => {
  joinScreen.classList.add("hidden");
  firstScreen.classList.remove("hidden");
};

// Panel buttons
document.getElementById("hostBtn").onclick = host;
document.getElementById("joinBtn").onclick = () => {
  if (peer) {
    peer.destroy();
    peer = null;
  }
  stopHosting();
  shareId.textContent = "";
  showJoinScreen();
};

// Hide all main UI at start
camera.classList.add("hidden");
overlayCanvas.classList.add("hidden");
gridCanvas.classList.add("hidden");
panel.classList.add("hidden");
topBar.classList.add("hidden");

/* ================= CANVAS ================= */
const ctx = overlayCanvas.getContext("2d");
const gtx = gridCanvas.getContext("2d");

function resize() {
  overlayCanvas.width = gridCanvas.width = innerWidth;
  overlayCanvas.height = gridCanvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* ================= IMAGE ================= */
let img = new Image();
let sketchImg = null;
let mode = "image";

let pos = { x: innerWidth/2, y: innerHeight/2 };
let scale = 1;
let rot = 0;
let opacityVal = 0.6;

let locked = false;
let showGrid = false;

upload.onchange = e => {
  img.src = URL.createObjectURL(e.target.files[0]);
  img.onload = makeSketch;
};

function makeSketch() {
  const c = document.createElement("canvas");
  c.width = img.width;
  c.height = img.height;
  const cx = c.getContext("2d");
  cx.drawImage(img,0,0);
  const d = cx.getImageData(0,0,c.width,c.height);
  for(let i=0;i<d.data.length;i+=4){
    const g=(d.data[i]+d.data[i+1]+d.data[i+2])/3;
    d.data[i]=d.data[i+1]=d.data[i+2]=g>150?255:0;
  }
  cx.putImageData(d,0,0);
  sketchImg = new Image();
  sketchImg.src = c.toDataURL();
}

/* ================= UI ================= */
opacity.oninput = e => opacityVal = +e.target.value;
sketchBtn.onclick = () => mode = "sketch";
imageBtn.onclick = () => mode = "image";

lockBtn.onclick = () => {
  locked = !locked;
  lockBtn.textContent = locked ? "üîí Locked" : "üîì Move";
};

gridBtn.onclick = () => showGrid = !showGrid;

fullscreenBtn.onclick = () => {
  document.fullscreenElement
    ? document.exitFullscreen()
    : document.documentElement.requestFullscreen();
};

/* ================= DOUBLE TAP UI ================= */
let lastTap = 0;
overlayCanvas.addEventListener("touchend", () => {
  const now = Date.now();
  if (now - lastTap < 300) {
    panel.classList.toggle("hidden");
    topBar.classList.toggle("hidden");
  }
  lastTap = now;
});

/* ================= GESTURES ================= */
let g = null;
overlayCanvas.addEventListener("touchstart", e => {
  if (locked) return;
  const t = [...e.touches];
  g = {
    startPos: { ...pos },
    startScale: scale,
    startRot: rot,
    c0: center(t),
    d0: t.length>1 ? dist(t) : 0,
    a0: t.length>1 ? ang(t) : 0
  };
});

overlayCanvas.addEventListener("touchmove", e => {
  if (locked || !g) return;
  e.preventDefault();
  const t = [...e.touches];
  const c = center(t);
  pos.x = g.startPos.x + (c.x - g.c0.x);
  pos.y = g.startPos.y + (c.y - g.c0.y);
  if (t.length > 1) {
    scale = g.startScale * (dist(t) / g.d0);
    rot = g.startRot + (ang(t) - g.a0);
  }
},{ passive:false });

function dist(t){return Math.hypot(t[1].clientX-t[0].clientX,t[1].clientY-t[0].clientY);}
function ang(t){return Math.atan2(t[1].clientY-t[0].clientY,t[1].clientX-t[0].clientX);}
function center(t){let x=0,y=0;t.forEach(p=>{x+=p.clientX;y+=p.clientY});return{x:x/t.length,y:y/t.length};}

/* ================= GRID ================= */
function drawGrid() {
  gtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
  if (!showGrid) return;
  gtx.strokeStyle = "rgba(255,255,255,.15)";
  for(let i=0;i<gridCanvas.width;i+=60){
    gtx.beginPath(); gtx.moveTo(i,0); gtx.lineTo(i,gridCanvas.height); gtx.stroke();
  }
  for(let i=0;i<gridCanvas.height;i+=60){
    gtx.beginPath(); gtx.moveTo(0,i); gtx.lineTo(gridCanvas.width,i); gtx.stroke();
  }
}

/* ================= RENDER ================= */
function render() {
  if (!renderActive) return;
  ctx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  const src = mode==="sketch" ? sketchImg : img;
  if (src) {
    ctx.save();
    ctx.translate(pos.x,pos.y);
    ctx.rotate(rot);
    ctx.globalAlpha = opacityVal;
    ctx.drawImage(
      src,
      -src.width*scale/2,
      -src.height*scale/2,
      src.width*scale,
      src.height*scale
    );
    ctx.restore();
  }
  drawGrid();
  requestAnimationFrame(render);
}
render();

/* ================= SCREEN SHARE ================= */
let peer, call;
let hostStream = null;
let isHosting = false;
let canvasStream = null;
let canvasStreamInterval = null;
let resizeHandler = null;

// Detect if device is mobile
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
         (window.innerWidth <= 768 && 'ontouchstart' in window);
}

// Create a composite canvas stream (camera + overlay)
function createCompositeStream() {
  // Create a new canvas for compositing
  const compositeCanvas = document.createElement("canvas");
  compositeCanvas.width = overlayCanvas.width || window.innerWidth;
  compositeCanvas.height = overlayCanvas.height || window.innerHeight;
  const compositeCtx = compositeCanvas.getContext("2d");
  
  // Update canvas size if window resizes
  function updateCanvasSize() {
    compositeCanvas.width = overlayCanvas.width || window.innerWidth;
    compositeCanvas.height = overlayCanvas.height || window.innerHeight;
  }
  resizeHandler = updateCanvasSize;
  window.addEventListener("resize", resizeHandler);
  
  // Capture stream from composite canvas
  const stream = compositeCanvas.captureStream(30); // 30 FPS
  
  // Function to draw composite frame
  function drawCompositeFrame() {
    if (!isHosting || !camera.srcObject || camera.readyState !== 4) return;
    
    // Update canvas size if needed
    if (compositeCanvas.width !== overlayCanvas.width || 
        compositeCanvas.height !== overlayCanvas.height) {
      updateCanvasSize();
    }
    
    // Clear and draw camera frame
    try {
      compositeCtx.drawImage(camera, 0, 0, compositeCanvas.width, compositeCanvas.height);
      
      // Draw overlay canvas on top
      compositeCtx.drawImage(overlayCanvas, 0, 0);
      
      // Draw grid canvas on top
      compositeCtx.drawImage(gridCanvas, 0, 0);
    } catch (e) {
      // Silently handle any drawing errors
      console.warn("Error drawing composite frame:", e);
    }
  }
  
  // Wait for camera to be ready, then start capturing
  function startCapturing() {
    if (camera.readyState === 4) {
      canvasStreamInterval = setInterval(drawCompositeFrame, 33); // ~30 FPS
    } else {
      camera.addEventListener("loadedmetadata", () => {
        if (isHosting && !canvasStreamInterval) {
          canvasStreamInterval = setInterval(drawCompositeFrame, 33);
        }
      }, { once: true });
    }
  }
  
  startCapturing();
  
  return stream;
}

function stopHosting() {
  if (call) {
    call.close();
    call = null;
  }
  if (hostStream) {
    hostStream.getTracks().forEach(track => track.stop());
    hostStream = null;
  }
  if (canvasStreamInterval) {
    clearInterval(canvasStreamInterval);
    canvasStreamInterval = null;
  }
  if (canvasStream) {
    canvasStream.getTracks().forEach(track => track.stop());
    canvasStream = null;
  }
  if (resizeHandler) {
    window.removeEventListener("resize", resizeHandler);
    resizeHandler = null;
  }
  isHosting = false;
  shareId.textContent = "Sharing stopped";
  shareId.style.color = "#ef4444";
}

function host() {
  if (isHosting) {
    alert("Already hosting. Please stop the current session first.");
    return;
  }
  
  // Clean up any existing peer
  if (peer) {
    peer.destroy();
  }
  
  // Ensure camera is started
  if (!camera.srcObject) {
    startCamera();
  }
  
  isHosting = true;
  shareId.textContent = "Starting host...";
  shareId.style.color = "#fbbf24";
  
  peer = new Peer({
    debug: 2,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });
  
  peer.on("open", async (id) => {
    shareId.textContent = "Share ID: " + id;
    shareId.style.color = "#4ade80";
    
    try {
      // Check if device is mobile or if getDisplayMedia is not available
      const isMobile = isMobileDevice();
      const hasDisplayMedia = navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia;
      
      if (isMobile || !hasDisplayMedia) {
        // For mobile devices, use canvas capture instead
        // Wait a bit for camera to be ready
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (!camera.srcObject) {
          throw new Error("Camera not available. Please ensure camera permissions are granted.");
        }
        
        // Create composite stream from canvas
        hostStream = createCompositeStream();
        canvasStream = hostStream;
        
        shareId.textContent = "Share ID: " + id + " (Mobile Mode)";
        
      } else {
        // Desktop: Use screen sharing
        hostStream = await navigator.mediaDevices.getDisplayMedia({ 
          video: { 
            cursor: "always",
            displaySurface: "monitor"
          },
          audio: false 
        });
        
        // Handle when user stops sharing
        hostStream.getVideoTracks()[0].onended = () => {
          stopHosting();
        };
      }
      
    } catch (err) {
      console.error("Error getting media stream:", err);
      isHosting = false;
      shareId.textContent = "Error: Could not start sharing";
      shareId.style.color = "#ef4444";
      
      if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
        alert("Permission denied. Please allow camera/screen sharing access.");
      } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
        alert("No camera found. Please ensure your device has a camera.");
      } else {
        alert("Could not start sharing: " + err.message);
      }
    }
  });
  
  peer.on("error", (err) => {
    console.error("Peer error:", err);
    shareId.textContent = "Error: " + err.message;
    shareId.style.color = "#ef4444";
    isHosting = false;
  });
  
  peer.on("call", (incomingCall) => {
    if (hostStream) {
      incomingCall.answer(hostStream);
      call = incomingCall;
      
      call.on("close", () => {
        console.log("Call closed");
      });
      
      call.on("error", (err) => {
        console.error("Call error:", err);
      });
    } else {
      console.error("No stream available to answer call");
      incomingCall.close();
    }
  });
}

function join(id) {
  // Clean up any existing peer
  if (peer) {
    peer.destroy();
  }
  
  if (!id || id.trim() === "") {
    alert("Please enter a valid Share ID");
    return;
  }
  
  peer = new Peer({
    debug: 2,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });
  
  peer.on("open", () => {
    console.log("Joining with ID:", id);
    
    // PeerJS requires a stream when calling, so we create a minimal dummy stream
    // We'll use a canvas-based video stream to avoid requesting camera permissions
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, 1, 1);
    
    const stream = canvas.captureStream(1); // 1 FPS is enough for a dummy stream
    
    // Small delay to ensure peer is fully ready
    setTimeout(() => {
      try {
        call = peer.call(id.trim(), stream);
        
        if (!call) {
          throw new Error("Could not initiate call");
        }
        
        call.on("stream", (remoteStream) => {
          console.log("Received remote stream");
          // Stop the dummy stream once we get the real stream
          stream.getTracks().forEach(track => track.stop());
          enterViewerMode(remoteStream);
        });
        
        call.on("close", () => {
          console.log("Call closed");
          stream.getTracks().forEach(track => track.stop());
          alert("Connection to host lost");
          location.reload();
        });
        
        call.on("error", (err) => {
          console.error("Call error:", err);
          stream.getTracks().forEach(track => track.stop());
          alert("Connection error: " + err.message);
          location.reload();
        });
      } catch (err) {
        console.error("Error initiating call:", err);
        stream.getTracks().forEach(track => track.stop());
        alert("Could not connect to host. Please check the Share ID and try again.");
        camera.classList.add("hidden");
        overlayCanvas.classList.add("hidden");
        gridCanvas.classList.add("hidden");
        panel.classList.add("hidden");
        topBar.classList.add("hidden");
        joinScreen.classList.remove("hidden");
      }
    }, 100);
  });
  
  peer.on("error", (err) => {
    console.error("Peer error:", err);
    alert("Connection error: " + err.message);
    camera.classList.add("hidden");
    overlayCanvas.classList.add("hidden");
    gridCanvas.classList.add("hidden");
    panel.classList.add("hidden");
    topBar.classList.add("hidden");
    joinScreen.classList.remove("hidden");
  });
}

function enterViewerMode(stream) {
  appMode = "viewer";
  renderActive = false;

  if (camera.srcObject) {
    camera.srcObject.getTracks().forEach(t => t.stop());
    camera.srcObject = null;
  }

  panel.classList.add("hidden");
  topBar.classList.add("hidden");
  overlayCanvas.classList.add("hidden");
  gridCanvas.classList.add("hidden");

  remoteVideo.srcObject = stream;
  remoteVideo.muted = true;
  remoteVideo.play();
  remoteVideo.classList.remove("hidden");
}

/* Exit viewer */
remoteVideo.addEventListener("touchend", () => {
  if (appMode === "viewer" && confirm("Exit viewer?")) {
    location.reload();
  }
});
</script>

</body>
</html>
