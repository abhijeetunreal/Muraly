<!DOCTYPE html>
<html lang="en">
<head>

<!-- Primary Meta Tags -->
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Muraly ‚Äî AR Mural Maker & Wall Visualization App</title>
<meta name="title" content="Muraly ‚Äî AR Mural Maker & Wall Visualization App" />
<meta name="description" content="Muraly is an augmented reality mural maker that lets you visualize wall art and murals in real spaces before painting or printing." />
<meta name="author" content="Codefrydev" />
<meta name="keywords" content="Muraly, AR mural maker, augmented reality wall art, mural visualization, AR design app, wall design, interior visualization" />
<meta name="robots" content="index, follow" />
<link rel="canonical" href="https://codefrydev.in/metatag/" />

<!-- Theme & Icons -->
<meta name="theme-color" content="#0ea5e9" />
<meta name="msapplication-TileColor" content="#0ea5e9" />
<link rel="icon" href="https://codefrydev.in/favicon-32x32.png" />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://codefrydev.in/metatag/" />
<meta property="og:title" content="Muraly ‚Äî Design & Preview Murals in AR" />
<meta property="og:description" content="Preview murals on real walls using augmented reality. Muraly helps artists and designers plan wall art with confidence." />
<meta property="og:image" content="https://codefrydev.in/images/IconCodefrydev.svg" />
<meta property="og:site_name" content="Muraly -AR Mural Maker & Wall Visualization App" />

<!-- Twitter -->
<meta name="twitter:card" content="Visualize murals and wall art in real spaces using AR. Create, preview, and design with Muraly." />
<meta name="twitter:title" content="Muraly ‚Äî Design & Preview Murals in AR" />
<meta name="twitter:description" content="Preview murals on real walls using augmented reality. Muraly helps artists and designers plan wall art with confidence." />
<meta name="twitter:image" content="https://codefrydev.in/images/IconCodefrydev.svg" />

<style>
:root { 
  --glass: rgba(15, 15, 15, 0.75);
  --glass-light: rgba(255, 255, 255, 0.1);
  --primary: #0ea5e9;
  --primary-dark: #0284c7;
  --success: #10b981;
  --warning: #f59e0b;
  --danger: #ef4444;
  --gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --gradient-2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  --gradient-3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  touch-action: none;
}

body {
  background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
  overflow: hidden;
}

video, canvas {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
}

#camera { object-fit: cover; z-index: 1; }
#overlayCanvas { z-index: 2; }
#gridCanvas { z-index: 3; pointer-events: none; }

#panel {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: calc(100% - 32px);
  max-width: 480px;
  background: var(--glass);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--glass-light);
  border-radius: 24px;
  padding: 20px;
  color: white;
  z-index: 10;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

#topBar {
  position: fixed;
  top: 16px;
  right: 16px;
  display: flex;
  gap: 12px;
  z-index: 10;
}

.iconBtn {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: var(--glass);
  backdrop-filter: blur(16px) saturate(180%);
  border: 1px solid var(--glass-light);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

.iconBtn:hover {
  transform: scale(1.05);
  background: rgba(255, 255, 255, 0.15);
}

.iconBtn:active {
  transform: scale(0.95);
}

.hidden { display: none !important; }

.row { 
  display: flex; 
  gap: 12px; 
  margin-bottom: 14px;
  align-items: center;
}

label { 
  width: 80px; 
  font-size: 13px; 
  opacity: 0.85;
  font-weight: 500;
}

input[type="range"] { 
  flex: 1; 
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--primary);
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(14, 165, 233, 0.4);
  transition: all 0.2s ease;
}

input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.2);
  background: var(--primary-dark);
}

input[type="file"] { 
  flex: 1; 
  color: white;
  font-size: 13px;
  padding: 8px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid var(--glass-light);
  cursor: pointer;
  transition: all 0.2s ease;
}

input[type="file"]:hover {
  background: rgba(255, 255, 255, 0.1);
}

button {
  flex: 1;
  padding: 14px 20px;
  border-radius: 14px;
  border: none;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
  color: white;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid var(--glass-light);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  position: relative;
  overflow: hidden;
}

button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  transition: left 0.5s ease;
}

button:hover::before {
  left: 100%;
}

button:hover {
  transform: translateY(-2px);
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.1) 100%);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

button:active {
  transform: translateY(0);
}

button.primary {
  background: var(--gradient-3);
  border: none;
}

button.primary:hover {
  background: linear-gradient(135deg, #3d9bf0 0%, #00d9f5 100%);
}

button.success {
  background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
  border: none;
}

button.success:hover {
  background: linear-gradient(135deg, #059669 0%, #047857 100%);
}

button.danger {
  background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
  border: none;
}

button.danger:hover {
  background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
}

button:disabled,
button.disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
  background: rgba(255, 255, 255, 0.05) !important;
  border-color: rgba(255, 255, 255, 0.1) !important;
  box-shadow: none !important;
}

button:disabled::before,
button.disabled::before {
  display: none;
}

button:disabled:hover,
button.disabled:hover {
  transform: none !important;
  background: rgba(255, 255, 255, 0.05) !important;
  box-shadow: none !important;
}

hr {
  border: none;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  margin: 16px 0;
}

/* Share Link Styles */
#shareLinkContainer {
  margin-top: 12px;
  padding: 16px;
  background: rgba(14, 165, 233, 0.1);
  border-radius: 16px;
  border: 1px solid rgba(14, 165, 233, 0.3);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(14, 165, 233, 0.4);
  }
  50% {
    box-shadow: 0 0 0 8px rgba(14, 165, 233, 0);
  }
}

#shareLinkContainer.hidden {
  display: none;
}

#shareLinkLabel {
  font-size: 12px;
  opacity: 0.8;
  margin-bottom: 8px;
  display: block;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

#shareLink {
  display: flex;
  gap: 8px;
  align-items: center;
}

#shareLinkInput {
  flex: 1;
  padding: 10px 14px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(14, 165, 233, 0.3);
  border-radius: 12px;
  color: white;
  font-size: 13px;
  font-family: 'Courier New', monospace;
  outline: none;
  transition: all 0.2s ease;
}

#shareLinkInput:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
}

#copyBtn {
  padding: 10px 16px;
  background: var(--gradient-3);
  border: none;
  border-radius: 12px;
  color: white;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

#copyBtn:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(14, 165, 233, 0.4);
}

#copyBtn:active {
  transform: scale(0.95);
}

#copyBtn.copied {
  background: var(--success);
  animation: checkmark 0.3s ease;
}

@keyframes checkmark {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

#shareId {
  font-size: 13px;
  opacity: 0.9;
  padding: 12px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.05);
  text-align: center;
  font-weight: 500;
  transition: all 0.3s ease;
}

#shareId.success {
  background: rgba(16, 185, 129, 0.15);
  color: #6ee7b7;
  border: 1px solid rgba(16, 185, 129, 0.3);
}

#shareId.error {
  background: rgba(239, 68, 68, 0.15);
  color: #fca5a5;
  border: 1px solid rgba(239, 68, 68, 0.3);
}

#shareId.warning {
  background: rgba(245, 158, 11, 0.15);
  color: #fcd34d;
  border: 1px solid rgba(245, 158, 11, 0.3);
}

/* First Screen Styles */
#firstScreen {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-image: url('https://upload.wikimedia.org/wikipedia/commons/2/28/Odissi_murals_in_Bhubaneswar.gif');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  z-index: 1000;
  animation: fadeIn 0.5s ease;
}

#firstScreen::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(15, 15, 35, 0.6) 0%, rgba(26, 26, 62, 0.6) 50%, rgba(15, 15, 35, 0.6) 100%);
  z-index: -1;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

#firstScreen h2 {
  color: white;
  margin-bottom: 40px;
  font-size: 32px;
  font-weight: 700;
  background: var(--gradient-3);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-align: center;
  animation: slideDown 0.6s ease;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

#firstScreen .button-group {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

#firstScreen button {
  padding: 20px 48px;
  font-size: 18px;
  font-weight: 700;
  border-radius: 20px;
  min-width: 180px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

#hostSelectBtn {
  background: var(--gradient-3);
}

#joinSelectBtn {
  background: var(--gradient-1);
}

/* Join Screen Styles */
#joinScreen {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 50%, #0f0f23 100%);
  z-index: 1000;
  padding: 20px;
}

#joinScreen h2 {
  color: white;
  margin-bottom: 24px;
  font-size: 28px;
  font-weight: 700;
  background: var(--gradient-1);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-align: center;
}

#joinScreen .form-container {
  width: 100%;
  max-width: 400px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

#joinKeyInput {
  padding: 14px 18px;
  font-size: 15px;
  width: 100%;
  background: var(--glass);
  backdrop-filter: blur(16px);
  border: 1px solid var(--glass-light);
  border-radius: 14px;
  color: white;
  outline: none;
  transition: all 0.2s ease;
}

#joinKeyInput:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
  background: rgba(15, 15, 15, 0.85);
}

#joinKeyInput::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

#joinKeyBtn {
  padding: 14px 24px;
  font-size: 15px;
  font-weight: 600;
  width: 100%;
  background: var(--gradient-1);
  border: none;
  border-radius: 14px;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
}

#joinKeyBtn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

#joinKeyBtn:active {
  transform: translateY(0);
}

#backToFirstBtn {
  position: fixed;
  top: 20px;
  left: 20px;
  background: var(--glass);
  backdrop-filter: blur(16px) saturate(180%);
  border: 1px solid var(--glass-light);
  border-radius: 12px;
  color: rgba(255, 255, 255, 0.9);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  padding: 10px 16px;
  z-index: 1001;
  display: flex;
  align-items: center;
  gap: 6px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

#backToFirstBtn:hover {
  color: white;
  background: rgba(255, 255, 255, 0.15);
  transform: translateX(-3px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
}

#backToFirstBtn:active {
  transform: translateX(-1px);
}

/* Viewer */
#remoteVideo {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  object-fit: contain;
  background: black;
  z-index: 999;
}
</style>
</head>


<body>

<!-- FIRST SCREEN: Host/Join selection -->
<div id="firstScreen">
  <h2>Welcome to Muraly</h2>
  <div class="button-group">
    <button id="hostSelectBtn">üì° Host Session</button>
    <button id="joinSelectBtn">üîó Join Session</button>
  </div>
</div>

<!-- JOIN SCREEN: Enter key -->
<div id="joinScreen" class="hidden">
  <h2>Join a Session</h2>
  <div class="form-container">
    <input id="joinKeyInput" type="text" placeholder="Enter Share ID or Link">
    <button id="joinKeyBtn">Join Session</button>
  </div>
  
</div>
<button id="backToFirstBtn">‚Üê Back</button>

<!-- HOST AR -->
<video id="camera" autoplay playsinline></video>
<canvas id="overlayCanvas"></canvas>
<canvas id="gridCanvas"></canvas>

<div id="topBar">
  <div class="iconBtn" id="fullscreenBtn">‚õ∂</div>
</div>

<div id="panel">
  <div class="row">
    <label>Image</label>
    <input type="file" id="upload" accept="image/*">
  </div>

  <div class="row">
    <label>Opacity</label>
    <input type="range" id="opacity" min="0" max="1" step="0.01" value="0.6">
  </div>

  <div class="row">
    <button id="sketchBtn">‚úèÔ∏è Sketch</button>
    <button id="imageBtn">üñº Image</button>
  </div>

  <div class="row">
    <button id="lockBtn">üîì Move</button>
    <button id="gridBtn">Grid</button>
  </div>

  <hr style="opacity:.2">

  <div class="row">
    <button id="hostBtn" class="primary">üì° Host</button>
    
  </div>

  <div id="shareLinkContainer" class="hidden">
    <label id="shareLinkLabel">Share this link to invite others:</label>
    <div id="shareLink">
      <input type="text" id="shareLinkInput" readonly>
      <button id="copyBtn">Copy</button>
    </div>
  </div>

  <div id="shareId"></div>
</div>

<!-- VIEWER -->
<video id="remoteVideo" autoplay playsinline muted class="hidden"></video>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script>

// ================= APP MODE =================
let appMode = "host";
let renderActive = true;

/* ================= CAMERA ================= */

function startCamera() {
  navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" } })
    .then(s => camera.srcObject = s);
}
// ========== FIRST SCREEN LOGIC ==========
const firstScreen = document.getElementById("firstScreen");
const joinScreen = document.getElementById("joinScreen");
const hostSelectBtn = document.getElementById("hostSelectBtn");
const joinSelectBtn = document.getElementById("joinSelectBtn");
const joinKeyInput = document.getElementById("joinKeyInput");
const joinKeyBtn = document.getElementById("joinKeyBtn");
const backToFirstBtn = document.getElementById("backToFirstBtn");

function showHostScreen() {
  firstScreen.classList.add("hidden");
  joinScreen.classList.add("hidden");
  backToFirstBtn.classList.add("hidden");
  camera.classList.remove("hidden");
  overlayCanvas.classList.remove("hidden");
  gridCanvas.classList.remove("hidden");
  panel.classList.remove("hidden");
  topBar.classList.remove("hidden");
  startCamera();
  // Don't auto-start hosting, let user click Host button
}

function showJoinScreen() {
  firstScreen.classList.add("hidden");
  joinScreen.classList.remove("hidden");
  backToFirstBtn.classList.remove("hidden");
  joinKeyInput.value = "";
  joinKeyInput.focus();
}

function doJoin() {
  const idOrLink = joinKeyInput.value.trim();
  if (!idOrLink) {
    joinKeyInput.focus();
    return;
  }
  joinScreen.classList.add("hidden");
  backToFirstBtn.classList.add("hidden");
  // Show host UI while waiting for stream
  camera.classList.remove("hidden");
  overlayCanvas.classList.remove("hidden");
  gridCanvas.classList.remove("hidden");
  panel.classList.remove("hidden");
  topBar.classList.remove("hidden");
  join(idOrLink);
}

hostSelectBtn.onclick = showHostScreen;
joinSelectBtn.onclick = showJoinScreen;
joinKeyBtn.onclick = doJoin;
joinKeyInput.addEventListener("keydown", e => { if (e.key === "Enter") doJoin(); });
backToFirstBtn.onclick = () => {
  joinScreen.classList.add("hidden");
  backToFirstBtn.classList.add("hidden");
  firstScreen.classList.remove("hidden");
};

// Panel buttons
document.getElementById("hostBtn").onclick = host;


// Hide all main UI at start
camera.classList.add("hidden");
overlayCanvas.classList.add("hidden");
gridCanvas.classList.add("hidden");
panel.classList.add("hidden");
topBar.classList.add("hidden");
backToFirstBtn.classList.add("hidden");

/* ================= CANVAS ================= */
const ctx = overlayCanvas.getContext("2d");
const gtx = gridCanvas.getContext("2d");

function resize() {
  overlayCanvas.width = gridCanvas.width = innerWidth;
  overlayCanvas.height = gridCanvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* ================= IMAGE ================= */
let img = new Image();
let sketchImg = null;
let mode = "image";

let pos = { x: innerWidth/2, y: innerHeight/2 };
let scale = 1;
let rot = 0;
let opacityVal = 0.6;

let locked = false;
let showGrid = false;

upload.onchange = e => {
  img.src = URL.createObjectURL(e.target.files[0]);
  img.onload = makeSketch;
};

function makeSketch() {
  const c = document.createElement("canvas");
  c.width = img.width;
  c.height = img.height;
  const cx = c.getContext("2d");
  cx.drawImage(img,0,0);
  const d = cx.getImageData(0,0,c.width,c.height);
  for(let i=0;i<d.data.length;i+=4){
    const g=(d.data[i]+d.data[i+1]+d.data[i+2])/3;
    d.data[i]=d.data[i+1]=d.data[i+2]=g>150?255:0;
  }
  cx.putImageData(d,0,0);
  sketchImg = new Image();
  sketchImg.src = c.toDataURL();
}

/* ================= UI ================= */
opacity.oninput = e => opacityVal = +e.target.value;
sketchBtn.onclick = () => mode = "sketch";
imageBtn.onclick = () => mode = "image";

lockBtn.onclick = () => {
  locked = !locked;
  lockBtn.textContent = locked ? "üîí Locked" : "üîì Move";
};

gridBtn.onclick = () => showGrid = !showGrid;

fullscreenBtn.onclick = () => {
  document.fullscreenElement
    ? document.exitFullscreen()
    : document.documentElement.requestFullscreen();
};

/* ================= DOUBLE TAP/CLICK UI ================= */
let lastTap = 0;
let lastTapPos = { x: 0, y: 0 };
let isDoubleTap = false;
let uiHiddenTime = 0;
let preventGestureUntil = 0;

overlayCanvas.addEventListener("touchend", (e) => {
  const now = Date.now();
  const touch = e.changedTouches[0];
  const tapX = touch.clientX;
  const tapY = touch.clientY;
  
  // Check if this is a double-tap (within 300ms and 50px distance)
  const timeDiff = now - lastTap;
  const distDiff = Math.hypot(tapX - lastTapPos.x, tapY - lastTapPos.y);
  
  if (timeDiff < 300 && distDiff < 50 && e.touches.length === 0) {
    isDoubleTap = true;
    e.preventDefault();
    e.stopPropagation();
    
    // Prevent gesture handling for a short time after double-tap
    preventGestureUntil = now + 500;
    
    // Toggle UI visibility
    const wasHidden = panel.classList.contains("hidden");
    panel.classList.toggle("hidden");
    topBar.classList.toggle("hidden");
    
    // If we just hid the UI, record the time to prevent immediate re-showing
    if (!wasHidden) {
      uiHiddenTime = now;
    }
    
    // Clear gesture state
    g = null;
    
    // Reset double-tap flag after a short delay
    setTimeout(() => {
      isDoubleTap = false;
    }, 100);
  } else {
    isDoubleTap = false;
  }
  
  lastTap = now;
  lastTapPos = { x: tapX, y: tapY };
  
  // Reset gesture state when all touches end
  if (e.touches.length === 0) {
    g = null;
  }
}, { passive: false });

// Double-click for desktop/mouse users
overlayCanvas.addEventListener("dblclick", (e) => {
  e.preventDefault();
  e.stopPropagation();
  panel.classList.toggle("hidden");
  topBar.classList.toggle("hidden");
});

/* ================= GESTURES ================= */
let g = null;
overlayCanvas.addEventListener("touchstart", e => {
  // Prevent gesture handling if we just had a double-tap or UI was recently hidden
  const now = Date.now();
  if (locked || isDoubleTap || now < preventGestureUntil || (now - uiHiddenTime < 300)) {
    g = null;
    return;
  }
  
  const t = [...e.touches];
  g = {
    startPos: { ...pos },
    startScale: scale,
    startRot: rot,
    c0: center(t),
    d0: t.length>1 ? dist(t) : 0,
    a0: t.length>1 ? ang(t) : 0
  };
});

overlayCanvas.addEventListener("touchmove", e => {
  // Prevent gesture handling if we just had a double-tap or UI was recently hidden
  const now = Date.now();
  if (locked || !g || isDoubleTap || now < preventGestureUntil || (now - uiHiddenTime < 300)) {
    if (isDoubleTap || now < preventGestureUntil) {
      e.preventDefault();
      e.stopPropagation();
    }
    return;
  }
  e.preventDefault();
  const t = [...e.touches];
  const c = center(t);
  pos.x = g.startPos.x + (c.x - g.c0.x);
  pos.y = g.startPos.y + (c.y - g.c0.y);
  if (t.length > 1) {
    scale = g.startScale * (dist(t) / g.d0);
    rot = g.startRot + (ang(t) - g.a0);
  }
},{ passive:false });


function dist(t){return Math.hypot(t[1].clientX-t[0].clientX,t[1].clientY-t[0].clientY);}
function ang(t){return Math.atan2(t[1].clientY-t[0].clientY,t[1].clientX-t[0].clientX);}
function center(t){let x=0,y=0;t.forEach(p=>{x+=p.clientX;y+=p.clientY});return{x:x/t.length,y:y/t.length};}

/* ================= MOUSE GESTURES ================= */
let mouseG = null;
let isMouseDown = false;

overlayCanvas.addEventListener("mousedown", e => {
  if (locked) return;
  isMouseDown = true;
  const startX = e.clientX;
  const startY = e.clientY;
  mouseG = {
    startPos: { ...pos },
    startScale: scale,
    startRot: rot,
    startX: startX,
    startY: startY,
    isRotating: e.shiftKey || e.button === 2, // Shift key or right mouse button for rotation
    lastAngle: 0
  };
  e.preventDefault();
});

overlayCanvas.addEventListener("mousemove", e => {
  if (locked || !mouseG || !isMouseDown) return;
  e.preventDefault();
  
  const dx = e.clientX - mouseG.startX;
  const dy = e.clientY - mouseG.startY;
  
  if (mouseG.isRotating) {
    // Rotation: calculate angle from center
    const centerX = mouseG.startPos.x;
    const centerY = mouseG.startPos.y;
    const angle1 = Math.atan2(mouseG.startY - centerY, mouseG.startX - centerX);
    const angle2 = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    const deltaAngle = angle2 - angle1;
    rot = mouseG.startRot + deltaAngle;
  } else {
    // Translation: move the image
    pos.x = mouseG.startPos.x + dx;
    pos.y = mouseG.startPos.y + dy;
  }
});

overlayCanvas.addEventListener("mouseup", e => {
  isMouseDown = false;
  mouseG = null;
});

overlayCanvas.addEventListener("mouseleave", () => {
  isMouseDown = false;
  mouseG = null;
});

// Mouse wheel for scaling
overlayCanvas.addEventListener("wheel", e => {
  if (locked) return;
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? 0.9 : 1.1; // Zoom out or zoom in
  const newScale = scale * delta;
  
  // Limit scale range
  if (newScale >= 0.1 && newScale <= 10) {
    // Scale from mouse position
    const rect = overlayCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate scale relative to mouse position
    const scaleChange = newScale / scale;
    pos.x = mouseX - (mouseX - pos.x) * scaleChange;
    pos.y = mouseY - (mouseY - pos.y) * scaleChange;
    
    scale = newScale;
  }
}, { passive: false });

// Prevent context menu on right click (for rotation)
overlayCanvas.addEventListener("contextmenu", e => {
  e.preventDefault();
});

/* ================= GRID ================= */
function drawGrid() {
  gtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
  if (!showGrid) return;
  gtx.strokeStyle = "rgba(255,255,255,.15)";
  for(let i=0;i<gridCanvas.width;i+=60){
    gtx.beginPath(); gtx.moveTo(i,0); gtx.lineTo(i,gridCanvas.height); gtx.stroke();
  }
  for(let i=0;i<gridCanvas.height;i+=60){
    gtx.beginPath(); gtx.moveTo(0,i); gtx.lineTo(gridCanvas.width,i); gtx.stroke();
  }
}

/* ================= RENDER ================= */
function render() {
  if (!renderActive) return;
  ctx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  const src = mode==="sketch" ? sketchImg : img;
  if (src) {
    ctx.save();
    ctx.translate(pos.x,pos.y);
    ctx.rotate(rot);
    ctx.globalAlpha = opacityVal;
    ctx.drawImage(
      src,
      -src.width*scale/2,
      -src.height*scale/2,
      src.width*scale,
      src.height*scale
    );
    ctx.restore();
  }
  drawGrid();
  requestAnimationFrame(render);
}
render();

/* ================= SCREEN SHARE ================= */
let peer, call;
let hostStream = null;
let isHosting = false;
let canvasStream = null;
let canvasStreamInterval = null;
let resizeHandler = null;

// Detect if device is mobile
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
         (window.innerWidth <= 768 && 'ontouchstart' in window);
}

// Create a composite canvas stream (camera + overlay)
function createCompositeStream() {
  // Create a new canvas for compositing
  const compositeCanvas = document.createElement("canvas");
  compositeCanvas.width = overlayCanvas.width || window.innerWidth;
  compositeCanvas.height = overlayCanvas.height || window.innerHeight;
  const compositeCtx = compositeCanvas.getContext("2d");
  
  // Update canvas size if window resizes
  function updateCanvasSize() {
    compositeCanvas.width = overlayCanvas.width || window.innerWidth;
    compositeCanvas.height = overlayCanvas.height || window.innerHeight;
  }
  resizeHandler = updateCanvasSize;
  window.addEventListener("resize", resizeHandler);
  
  // Capture stream from composite canvas
  const stream = compositeCanvas.captureStream(30); // 30 FPS
  
  // Function to draw composite frame
  function drawCompositeFrame() {
    if (!isHosting || !camera.srcObject || camera.readyState !== 4) return;
    
    // Update canvas size if needed
    if (compositeCanvas.width !== overlayCanvas.width || 
        compositeCanvas.height !== overlayCanvas.height) {
      updateCanvasSize();
    }
    
    // Clear and draw camera frame
    try {
      compositeCtx.drawImage(camera, 0, 0, compositeCanvas.width, compositeCanvas.height);
      
      // Draw overlay canvas on top
      compositeCtx.drawImage(overlayCanvas, 0, 0);
      
      // Draw grid canvas on top
      compositeCtx.drawImage(gridCanvas, 0, 0);
    } catch (e) {
      // Silently handle any drawing errors
      console.warn("Error drawing composite frame:", e);
    }
  }
  
  // Wait for camera to be ready, then start capturing
  function startCapturing() {
    if (camera.readyState === 4) {
      canvasStreamInterval = setInterval(drawCompositeFrame, 33); // ~30 FPS
    } else {
      camera.addEventListener("loadedmetadata", () => {
        if (isHosting && !canvasStreamInterval) {
          canvasStreamInterval = setInterval(drawCompositeFrame, 33);
        }
      }, { once: true });
    }
  }
  
  startCapturing();
  
  return stream;
}

function stopHosting() {
  if (call) {
    call.close();
    call = null;
  }
  if (hostStream) {
    hostStream.getTracks().forEach(track => track.stop());
    hostStream = null;
  }
  if (canvasStreamInterval) {
    clearInterval(canvasStreamInterval);
    canvasStreamInterval = null;
  }
  if (canvasStream) {
    canvasStream.getTracks().forEach(track => track.stop());
    canvasStream = null;
  }
  if (resizeHandler) {
    window.removeEventListener("resize", resizeHandler);
    resizeHandler = null;
  }
  isHosting = false;
  shareId.textContent = "";
  shareId.className = "";
  document.getElementById("shareLinkContainer").classList.add("hidden");
  document.getElementById("shareLinkInput").value = "";
  
  // Re-enable host button
  const hostBtn = document.getElementById("hostBtn");
  if (hostBtn) {
    hostBtn.disabled = false;
    hostBtn.classList.remove("disabled");
  }
}

function host() {
  if (isHosting) {
    alert("Already hosting. Please stop the current session first.");
    return;
  }
  
  // Clean up any existing peer
  if (peer) {
    peer.destroy();
  }
  
  // Ensure camera is started
  if (!camera.srcObject) {
    startCamera();
  }
  
  isHosting = true;
  shareId.textContent = "Starting host...";
  shareId.className = "warning";
  
  // Disable host button
  const hostBtn = document.getElementById("hostBtn");
  if (hostBtn) {
    hostBtn.disabled = true;
    hostBtn.classList.add("disabled");
  }
  
  peer = new Peer({
    debug: 2,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });
  
  peer.on("open", async (id) => {
    // Generate shareable link
    const shareLink = `${window.location.origin}${window.location.pathname}?join=${id}`;
    const shareLinkInput = document.getElementById("shareLinkInput");
    const shareLinkContainer = document.getElementById("shareLinkContainer");
    
    shareLinkInput.value = shareLink;
    shareLinkContainer.classList.remove("hidden");
    
    shareId.textContent = `Session ID: ${id}`;
    shareId.className = "success";
    
    try {
      // Check if device is mobile or if getDisplayMedia is not available
      const isMobile = isMobileDevice();
      const hasDisplayMedia = navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia;
      
      if (isMobile || !hasDisplayMedia) {
        // For mobile devices, use canvas capture instead
        // Wait a bit for camera to be ready
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (!camera.srcObject) {
          throw new Error("Camera not available. Please ensure camera permissions are granted.");
        }
        
        // Create composite stream from canvas
        hostStream = createCompositeStream();
        canvasStream = hostStream;
        
        shareId.textContent = `Session ID: ${id} (Mobile Mode)`;
        shareId.className = "success";
        
      } else {
        // Desktop: Use screen sharing
        hostStream = await navigator.mediaDevices.getDisplayMedia({ 
          video: { 
            cursor: "always",
            displaySurface: "monitor"
          },
          audio: false 
        });
        
        // Handle when user stops sharing
        hostStream.getVideoTracks()[0].onended = () => {
          stopHosting();
        };
      }
      
    } catch (err) {
      console.error("Error getting media stream:", err);
      isHosting = false;
      shareId.textContent = "Error: Could not start sharing";
      shareId.className = "error";
      document.getElementById("shareLinkContainer").classList.add("hidden");
      
      // Re-enable host button on error
      const hostBtn = document.getElementById("hostBtn");
      if (hostBtn) {
        hostBtn.disabled = false;
        hostBtn.classList.remove("disabled");
      }
      
      if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
        alert("Permission denied. Please allow camera/screen sharing access.");
      } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
        alert("No camera found. Please ensure your device has a camera.");
      } else {
        alert("Could not start sharing: " + err.message);
      }
    }
  });
  
  peer.on("error", (err) => {
    console.error("Peer error:", err);
    shareId.textContent = "Error: " + err.message;
    shareId.className = "error";
    document.getElementById("shareLinkContainer").classList.add("hidden");
    isHosting = false;
    
    // Re-enable host button on error
    const hostBtn = document.getElementById("hostBtn");
    if (hostBtn) {
      hostBtn.disabled = false;
      hostBtn.classList.remove("disabled");
    }
  });
  
  peer.on("call", (incomingCall) => {
    if (hostStream) {
      incomingCall.answer(hostStream);
      call = incomingCall;
      
      call.on("close", () => {
        console.log("Call closed");
      });
      
      call.on("error", (err) => {
        console.error("Call error:", err);
      });
    } else {
      console.error("No stream available to answer call");
      incomingCall.close();
    }
  });
}

function join(idOrLink) {
  // Clean up any existing peer
  if (peer) {
    peer.destroy();
  }
  
  // Extract ID from link if it's a full URL
  let id = idOrLink.trim();
  if (id.includes('?join=')) {
    id = id.split('?join=')[1].split('&')[0];
  } else if (id.includes('join=')) {
    id = id.split('join=')[1].split('&')[0];
  }
  
  if (!id || id === "") {
    alert("Please enter a valid Share ID or Link");
    return;
  }
  
  shareId.textContent = "Connecting...";
  shareId.className = "warning";
  
  peer = new Peer({
    debug: 2,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });
  
  peer.on("open", () => {
    console.log("Joining with ID:", id);
    
    // PeerJS requires a stream when calling, so we create a minimal dummy stream
    // We'll use a canvas-based video stream to avoid requesting camera permissions
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, 1, 1);
    
    const stream = canvas.captureStream(1); // 1 FPS is enough for a dummy stream
    
    // Small delay to ensure peer is fully ready
    setTimeout(() => {
      try {
        call = peer.call(id.trim(), stream);
        
        if (!call) {
          throw new Error("Could not initiate call");
        }
        
        call.on("stream", (remoteStream) => {
          console.log("Received remote stream");
          // Stop the dummy stream once we get the real stream
          stream.getTracks().forEach(track => track.stop());
          enterViewerMode(remoteStream);
        });
        
        call.on("close", () => {
          console.log("Call closed");
          stream.getTracks().forEach(track => track.stop());
          shareId.textContent = "Connection lost";
          shareId.className = "error";
          setTimeout(() => {
            alert("Connection to host lost");
            location.reload();
          }, 500);
        });
        
        call.on("error", (err) => {
          console.error("Call error:", err);
          stream.getTracks().forEach(track => track.stop());
          shareId.textContent = "Connection error";
          shareId.className = "error";
          setTimeout(() => {
            alert("Connection error: " + err.message);
            location.reload();
          }, 500);
        });
      } catch (err) {
        console.error("Error initiating call:", err);
        stream.getTracks().forEach(track => track.stop());
        shareId.textContent = "Connection failed";
        shareId.className = "error";
        setTimeout(() => {
          alert("Could not connect to host. Please check the Share ID and try again.");
          camera.classList.add("hidden");
          overlayCanvas.classList.add("hidden");
          gridCanvas.classList.add("hidden");
          panel.classList.add("hidden");
          topBar.classList.add("hidden");
          joinScreen.classList.remove("hidden");
        }, 500);
      }
    }, 100);
  });
  
  peer.on("error", (err) => {
    console.error("Peer error:", err);
    shareId.textContent = "Connection error";
    shareId.className = "error";
    setTimeout(() => {
      alert("Connection error: " + err.message);
      camera.classList.add("hidden");
      overlayCanvas.classList.add("hidden");
      gridCanvas.classList.add("hidden");
      panel.classList.add("hidden");
      topBar.classList.add("hidden");
      joinScreen.classList.remove("hidden");
    }, 500);
  });
}

function enterViewerMode(stream) {
  appMode = "viewer";
  renderActive = false;

  if (camera.srcObject) {
    camera.srcObject.getTracks().forEach(t => t.stop());
    camera.srcObject = null;
  }

  panel.classList.add("hidden");
  topBar.classList.add("hidden");
  overlayCanvas.classList.add("hidden");
  gridCanvas.classList.add("hidden");

  remoteVideo.srcObject = stream;
  remoteVideo.muted = true;
  remoteVideo.play();
  remoteVideo.classList.remove("hidden");
  
  shareId.textContent = "Connected to host";
  shareId.className = "success";
}

/* Exit viewer */
remoteVideo.addEventListener("touchend", () => {
  if (appMode === "viewer" && confirm("Exit viewer?")) {
    location.reload();
  }
});

// ================= COPY TO CLIPBOARD =================
const copyBtn = document.getElementById("copyBtn");
const shareLinkInput = document.getElementById("shareLinkInput");

copyBtn.addEventListener("click", async () => {
  try {
    await navigator.clipboard.writeText(shareLinkInput.value);
    const originalText = copyBtn.textContent;
    copyBtn.textContent = "‚úì Copied!";
    copyBtn.classList.add("copied");
    
    setTimeout(() => {
      copyBtn.textContent = originalText;
      copyBtn.classList.remove("copied");
    }, 2000);
  } catch (err) {
    // Fallback for older browsers
    shareLinkInput.select();
    document.execCommand("copy");
    const originalText = copyBtn.textContent;
    copyBtn.textContent = "‚úì Copied!";
    copyBtn.classList.add("copied");
    
    setTimeout(() => {
      copyBtn.textContent = originalText;
      copyBtn.classList.remove("copied");
    }, 2000);
  }
});

// ================= CHECK URL PARAMETERS =================
window.addEventListener("DOMContentLoaded", () => {
  const urlParams = new URLSearchParams(window.location.search);
  const joinId = urlParams.get("join");
  
  if (joinId) {
    // Automatically join if join parameter is in URL
    firstScreen.classList.add("hidden");
    joinScreen.classList.add("hidden");
    camera.classList.remove("hidden");
    overlayCanvas.classList.remove("hidden");
    gridCanvas.classList.remove("hidden");
    panel.classList.remove("hidden");
    topBar.classList.remove("hidden");
    join(joinId);
  }
});
</script>

</body>
</html>
