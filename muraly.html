<!DOCTYPE html>
<html lang="en">
<head>

<!-- Primary Meta Tags -->
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Muraly ‚Äî AR Mural Maker & Wall Visualization App</title>
<meta name="title" content="Muraly ‚Äî AR Mural Maker & Wall Visualization App" />
<meta name="description" content="Muraly is an augmented reality mural maker that lets you visualize wall art and murals in real spaces before painting or printing." />
<meta name="author" content="Codefrydev" />
<meta name="keywords" content="Muraly, AR mural maker, augmented reality wall art, mural visualization, AR design app, wall design, interior visualization" />
<meta name="robots" content="index, follow" />
<link rel="canonical" href="https://codefrydev.in/metatag/" />

<!-- Theme & Icons -->
<meta name="theme-color" content="#ff6b35" />
<meta name="msapplication-TileColor" content="#ff6b35" />
<link rel="icon" href="https://codefrydev.in/favicon-32x32.png" />

<!-- PWA Manifest -->
<link rel="manifest" href="/manifest.json" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Muraly" />
<meta name="mobile-web-app-capable" content="yes" />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://codefrydev.in/metatag/" />
<meta property="og:title" content="Muraly ‚Äî Design & Preview Murals in AR" />
<meta property="og:description" content="Preview murals on real walls using augmented reality. Muraly helps artists and designers plan wall art with confidence." />
<meta property="og:image" content="https://codefrydev.in/images/IconCodefrydev.svg" />
<meta property="og:site_name" content="Muraly -AR Mural Maker & Wall Visualization App" />

<!-- Twitter -->
<meta name="twitter:card" content="Visualize murals and wall art in real spaces using AR. Create, preview, and design with Muraly." />
<meta name="twitter:title" content="Muraly ‚Äî Design & Preview Murals in AR" />
<meta name="twitter:description" content="Preview murals on real walls using augmented reality. Muraly helps artists and designers plan wall art with confidence." />
<meta name="twitter:image" content="https://codefrydev.in/images/IconCodefrydev.svg" />

<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300..700&family=Limelight&display=swap" rel="stylesheet">
<style>
:root { 
  --glass: rgba(15, 15, 15, 0.85);
  --glass-light: rgba(255, 255, 255, 0.15);
  --primary: #ff6b35;
  --primary-dark: #e55a2b;
  --success: #06ffa5;
  --warning: #ffd23f;
  --danger: #ff1744;
  --gradient-1: linear-gradient(135deg, #ff6b35 0%, #f7931e 50%, #ff1744 100%);
  --gradient-2: linear-gradient(135deg, #06ffa5 0%, #00d4ff 50%, #667eea 100%);
  --gradient-3: linear-gradient(135deg, #ffd23f 0%, #ff6b35 50%, #ff1744 100%);
  --spray-blue: #00d4ff;
  --spray-pink: #ff1744;
  --spray-yellow: #ffd23f;
  --spray-green: #06ffa5;
  --spray-orange: #ff6b35;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  touch-action: none;
}

body {
  background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
  overflow: hidden;
}

video, canvas {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
}

#camera { object-fit: cover; z-index: 1; }
#overlayCanvas { z-index: 2; }
#gridCanvas { z-index: 3; pointer-events: none; }

#panel {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: calc(100% - 32px);
  max-width: 480px;
  background: 
    linear-gradient(135deg, rgba(15, 15, 15, 0.4) 0%, rgba(26, 15, 31, 0.4) 100%);
  backdrop-filter: blur(20px) saturate(180%);
  border: 3px solid;
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green), var(--spray-blue), var(--spray-pink)) 1;
  border-radius: 0;
  padding: 20px;
  color: white;
  z-index: 10;
  box-shadow: 
    0 2px 8px rgba(0, 0, 0, 0.15),
    0 0 0 1px rgba(255, 107, 53, 0.2);
  animation: slideUp 0.3s ease-out;
}

#panel::before {
  content: '';
  position: absolute;
  inset: -3px;
  background: linear-gradient(135deg, var(--spray-orange), var(--spray-green), var(--spray-blue), var(--spray-pink));
  z-index: -1;
  opacity: 0.3;
  filter: blur(8px);
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

#topBar {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  gap: 12px;
  z-index: 10;
}

.iconBtn {
  width: 48px;
  height: 48px;
  border-radius: 0;
  background: linear-gradient(135deg, rgba(15, 15, 15, 0.4) 0%, rgba(26, 15, 31, 0.4) 100%);
  backdrop-filter: blur(16px) saturate(180%);
  border: 2px solid;
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green)) 1;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 22px;
  cursor: pointer;
  transition: all 0.15s ease;
  box-shadow: 
    0 1px 3px rgba(0, 0, 0, 0.1),
    0 0 0 1px rgba(255, 107, 53, 0.2);
}

.iconBtn:hover {
  transform: scale(1.1);
  background: linear-gradient(135deg, rgba(255, 107, 53, 0.3) 0%, rgba(6, 255, 165, 0.3) 100%);
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green), var(--spray-blue)) 1;
  box-shadow: 
    0 2px 6px rgba(0, 0, 0, 0.15),
    0 0 0 1px rgba(255, 107, 53, 0.3);
}

.iconBtn:active {
  transform: scale(0.95);
}

.hidden { display: none !important; }

.row { 
  display: flex; 
  gap: 12px; 
  margin-bottom: 14px;
  align-items: center;
}

label { 
  width: 80px; 
  font-size: 12px; 
  opacity: 0.9;
  font-weight: 400;
  font-family: 'Comfortaa', cursive;
  letter-spacing: 0.5px;
  text-transform: uppercase;
}

input[type="range"] { 
  flex: 1; 
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--primary);
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(14, 165, 233, 0.4);
  transition: all 0.2s ease;
}

input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.2);
  background: var(--primary-dark);
}

input[type="file"] { 
  flex: 1; 
  color: white;
  font-size: 12px;
  font-family: 'Comfortaa', cursive;
  padding: 10px;
  border-radius: 0;
  background: rgba(10, 10, 26, 0.8);
  border: 2px solid;
  border-image: linear-gradient(135deg, rgba(255, 107, 53, 0.5), rgba(6, 255, 165, 0.5)) 1;
  cursor: pointer;
  transition: all 0.15s ease;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.3),
    0 0 0 1px rgba(255, 107, 53, 0.2);
}

input[type="file"]:hover {
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green), var(--spray-blue)) 1;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.2),
    0 0 0 1px rgba(255, 107, 53, 0.25);
}

input[type="file"]:hover {
  background: rgba(255, 255, 255, 0.1);
}

select, input[type="number"] {
  color: white;
  font-size: 12px;
  font-family: 'Comfortaa', cursive;
  border-radius: 4px;
  border: 2px solid rgba(255, 255, 255, 0.2);
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
}

select option {
  background: #1a1a3e;
  color: white;
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  opacity: 0.5;
}

button {
  flex: 1;
  padding: 12px 18px;
  border-radius: 0;
  border: 2px solid;
  border-image: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 107, 53, 0.6)) 1;
  background: linear-gradient(135deg, rgba(15, 15, 15, 0.9) 0%, rgba(26, 15, 31, 0.9) 100%);
  color: white;
  font-size: 13px;
  font-weight: 400;
  font-family: 'Comfortaa', cursive;
  letter-spacing: 0.5px;
  cursor: pointer;
  transition: all 0.15s ease;
  box-shadow: 
    0 1px 3px rgba(0, 0, 0, 0.1),
    0 0 0 1px rgba(255, 107, 53, 0.15);
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
}

button::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, transparent, rgba(255, 107, 53, 0.1), transparent);
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

button:hover::after {
  opacity: 1;
}

button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
  transition: left 0.3s ease;
}

button:hover::before {
  left: 100%;
}

button:hover {
  transform: translateY(-2px);
  background: linear-gradient(135deg, rgba(255, 107, 53, 0.2) 0%, rgba(6, 255, 165, 0.2) 100%);
  box-shadow: 
    0 2px 6px rgba(0, 0, 0, 0.15),
    0 0 0 1px rgba(255, 107, 53, 0.25);
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green)) 1;
}

button:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

button.primary {
  background: var(--gradient-3);
  border: 3px solid;
  border-image: linear-gradient(135deg, var(--spray-yellow), var(--spray-orange), var(--spray-pink)) 1;
  box-shadow: 
    0 1px 4px rgba(255, 107, 53, 0.15),
    0 0 0 1px rgba(255, 210, 63, 0.2);
}

button.primary:hover {
  background: linear-gradient(135deg, #ffd23f 0%, #ff6b35 50%, #ff1744 100%);
  border-image: linear-gradient(135deg, var(--spray-yellow), var(--spray-orange), var(--spray-pink), var(--spray-blue)) 1;
  box-shadow: 
    0 2px 6px rgba(255, 107, 53, 0.2),
    0 0 0 1px rgba(255, 210, 63, 0.3);
}

button.success {
  background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
  border: 2px solid rgba(255, 255, 255, 0.3);
}

button.success:hover {
  background: linear-gradient(135deg, #059669 0%, #047857 100%);
  border-color: rgba(255, 255, 255, 0.4);
}

button.danger {
  background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
  border: 2px solid rgba(255, 255, 255, 0.3);
}

button.danger:hover {
  background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
  border-color: rgba(255, 255, 255, 0.4);
}

button:disabled,
button.disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
  background: rgba(255, 255, 255, 0.05) !important;
  border-color: rgba(255, 255, 255, 0.1) !important;
  box-shadow: none !important;
}

button:disabled::before,
button.disabled::before {
  display: none;
}

button:disabled:hover,
button.disabled:hover {
  transform: none !important;
  background: rgba(255, 255, 255, 0.05) !important;
  box-shadow: none !important;
}

hr {
  border: none;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  margin: 16px 0;
}

/* Share Link Styles */
#shareLinkContainer {
  margin-top: 12px;
  padding: 16px;
  background: rgba(14, 165, 233, 0.1);
  border-radius: 16px;
  border: 1px solid rgba(14, 165, 233, 0.3);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(14, 165, 233, 0.4);
  }
  50% {
    box-shadow: 0 0 0 8px rgba(14, 165, 233, 0);
  }
}

#shareLinkContainer.hidden {
  display: none;
}

#shareLinkLabel {
  font-size: 12px;
  opacity: 0.8;
  margin-bottom: 8px;
  display: block;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

#shareLink {
  display: flex;
  gap: 8px;
  align-items: center;
}

#shareLinkInput {
  flex: 1;
  padding: 10px 14px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(14, 165, 233, 0.3);
  border-radius: 12px;
  color: white;
  font-size: 13px;
  font-family: 'Courier New', monospace;
  outline: none;
  transition: all 0.2s ease;
}

#shareLinkInput:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
}

#copyBtn {
  padding: 10px 16px;
  background: var(--gradient-3);
  border: none;
  border-radius: 12px;
  color: white;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

#copyBtn:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(14, 165, 233, 0.4);
}

#copyBtn:active {
  transform: scale(0.95);
}

#copyBtn.copied {
  background: var(--success);
  animation: checkmark 0.3s ease;
}

@keyframes checkmark {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

#shareId {
  font-size: 13px;
  opacity: 0.9;
  padding: 12px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.05);
  text-align: center;
  font-weight: 500;
  transition: all 0.3s ease;
}

#shareId.success {
  background: rgba(16, 185, 129, 0.15);
  color: #6ee7b7;
  border: 1px solid rgba(16, 185, 129, 0.3);
}

#shareId.error {
  background: rgba(239, 68, 68, 0.15);
  color: #fca5a5;
  border: 1px solid rgba(239, 68, 68, 0.3);
}

#shareId.warning {
  background: rgba(245, 158, 11, 0.15);
  color: #fcd34d;
  border: 1px solid rgba(245, 158, 11, 0.3);
}

/* First Screen Styles */
#firstScreen {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-image: url('https://upload.wikimedia.org/wikipedia/commons/2/28/Odissi_murals_in_Bhubaneswar.gif');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  z-index: 1000;
  animation: fadeIn 0.5s ease;
}

#firstScreen::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(15, 15, 35, 0.6) 0%, rgba(26, 26, 62, 0.6) 50%, rgba(15, 15, 35, 0.6) 100%);
  z-index: -1;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

#firstScreen h2 {
  color: white;
  margin-bottom: 40px;
  font-size: 72px;
  font-weight: 2000;
  font-family: 'Limelight', cursive;
  background: var(--gradient-3);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-align: center;
  animation: slideDown 0.6s ease;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

#firstScreen .button-group {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  justify-content: center;
}

#firstScreen button {
  padding: 14px 18px;
  font-size: 12px;
  font-weight: 400;
  font-family: 'Comfortaa';
  letter-spacing: 1.5px;
  border-radius: 0;
  min-width: 160px;
  border: 3px solid;
  text-transform: uppercase;
  transition: all 0.2s ease;
  position: relative;
  overflow: visible;
}

#firstScreen button::before {
  content: '';
  position: absolute;
  inset: -4px;
  background: inherit;
  filter: blur(12px);
  opacity: 0.6;
  z-index: -1;
}

#firstScreen button:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  border-color: rgba(255, 255, 255, 0.5);
}

#firstScreen button:active {
  transform: translateY(0) scale(0.98);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

#hostSelectBtn {
  background: var(--gradient-3);
  border-image: linear-gradient(135deg, var(--spray-yellow), var(--spray-orange), var(--spray-pink)) 1;
  box-shadow: 
    0 2px 6px rgba(255, 107, 53, 0.2),
    0 0 0 1px rgba(255, 210, 63, 0.25);
}

#hostSelectBtn:hover {
  box-shadow: 
    0 3px 8px rgba(255, 107, 53, 0.25),
    0 0 0 1px rgba(255, 210, 63, 0.35);
  transform: translateY(-3px) scale(1.02);
}

#joinSelectBtn {
  background: var(--gradient-1);
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-pink), var(--spray-blue)) 1;
  box-shadow: 
    0 2px 6px rgba(255, 23, 68, 0.2),
    0 0 0 1px rgba(255, 107, 53, 0.25);
}

#joinSelectBtn:hover {
  box-shadow: 
    0 3px 8px rgba(255, 23, 68, 0.25),
    0 0 0 1px rgba(255, 107, 53, 0.35);
  transform: translateY(-3px) scale(1.02);
}

/* Join Screen Styles */
#joinScreen {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 50%, #0f0f23 100%);
  z-index: 1000;
  padding: 20px;
}

#joinScreen h2 {
  color: white;
  margin-bottom: 24px;
  font-size: 28px;
  font-weight: 400;
  font-family: 'Limelight', cursive;
  background: var(--gradient-1);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-align: center;
}

#joinScreen .form-container {
  width: 100%;
  max-width: 400px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

#joinKeyInput {
  padding: 14px 18px;
  font-size: 14px;
  font-family: 'Comfortaa', cursive;
  letter-spacing: 0.5px;
  width: 100%;
  background: rgba(10, 10, 26, 0.8);
  backdrop-filter: blur(16px);
  border: 2px solid;
  border-image: linear-gradient(135deg, rgba(255, 107, 53, 0.5), rgba(6, 255, 165, 0.5)) 1;
  border-radius: 0;
  color: white;
  outline: none;
  transition: all 0.15s ease;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.3),
    0 0 0 1px rgba(255, 107, 53, 0.2);
}

#joinKeyInput:focus {
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green), var(--spray-blue)) 1;
  box-shadow: 
    0 0 0 3px rgba(255, 107, 53, 0.3),
    inset 0 2px 4px rgba(0, 0, 0, 0.3),
    0 0 20px rgba(255, 107, 53, 0.2);
  background: rgba(15, 15, 15, 0.9);
}

#joinKeyInput::placeholder {
  color: rgba(255, 255, 255, 0.5);
  font-family: 'Comfortaa', cursive;
}

#joinKeyBtn {
  padding: 14px 24px;
  font-size: 14px;
  font-weight: 400;
  font-family: 'Comfortaa', cursive;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  width: 100%;
  background: var(--gradient-1);
  border: 3px solid;
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-pink), var(--spray-blue)) 1;
  border-radius: 0;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 
    0 2px 6px rgba(255, 107, 53, 0.2),
    0 0 0 1px rgba(255, 107, 53, 0.2);
  position: relative;
}

#joinKeyBtn:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 
    0 3px 8px rgba(255, 107, 53, 0.25),
    0 0 0 1px rgba(255, 107, 53, 0.3);
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-pink), var(--spray-blue), var(--spray-green)) 1;
}

#joinKeyBtn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(255, 107, 53, 0.15);
}

#backToFirstBtn {
  position: fixed;
  top: 20px;
  left: 20px;
  background: linear-gradient(135deg, rgba(15, 15, 15, 0.4) 0%, rgba(26, 15, 31, 0.4) 100%);
  backdrop-filter: blur(16px) saturate(180%);
  border: 2px solid;
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green)) 1;
  border-radius: 0;
  color: rgba(255, 255, 255, 0.9);
  font-size: 13px;
  font-weight: 400;
  font-family: 'Comfortaa', cursive;
  letter-spacing: 0.5px;
  cursor: pointer;
  transition: all 0.15s ease;
  padding: 10px 16px;
  z-index: 1001;
  display: flex;
  align-items: center;
  gap: 6px;
  box-shadow: 
    0 1px 3px rgba(0, 0, 0, 0.1),
    0 0 0 1px rgba(255, 107, 53, 0.2);
}

#backToFirstBtn:hover {
  color: white;
  background: linear-gradient(135deg, rgba(255, 107, 53, 0.2) 0%, rgba(6, 255, 165, 0.2) 100%);
  transform: translateX(-3px);
  box-shadow: 
    0 2px 6px rgba(0, 0, 0, 0.15),
    0 0 0 1px rgba(255, 107, 53, 0.3);
  border-image: linear-gradient(135deg, var(--spray-orange), var(--spray-green), var(--spray-blue)) 1;
}

#backToFirstBtn:active {
  transform: translateX(-1px);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Viewer */
#remoteVideo {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  object-fit: contain;
  background: black;
  z-index: 999;
}
</style>
</head>


<body>

<!-- FIRST SCREEN: Host/Join selection -->
<div id="firstScreen">
  <h2>MURALY</h2>
  <div class="button-group">
    <button id="hostSelectBtn">Host Session</button>
    <button id="joinSelectBtn">Join Session</button>
  </div>
</div>

<!-- JOIN SCREEN: Enter key -->
<div id="joinScreen" class="hidden">
  <h2>Join a Session</h2>
  <div class="form-container">
    <input id="joinKeyInput" type="text" placeholder="Enter Share ID or Link">
    <button id="joinKeyBtn">Join Session</button>
  </div>
  
</div>
<button id="backToFirstBtn">‚Üê Back</button>

<!-- HOST AR -->
<video id="camera" autoplay playsinline></video>
<canvas id="overlayCanvas"></canvas>
<canvas id="gridCanvas"></canvas>

<div id="topBar">
  <div class="iconBtn" id="fullscreenBtn">‚õ∂</div>
</div>

<div id="panel">
  <div class="row">
    <label>Image</label>
    <input type="file" id="upload" accept="image/*">
  </div>

  <div class="row">
    <label>Opacity</label>
    <input type="range" id="opacity" min="0" max="1" step="0.01" value="0.6">
  </div>

  <div class="row">
    <button id="sketchBtn">‚úèÔ∏è Sketch</button>
    <button id="imageBtn">üñº Image</button>
  </div>

  <div class="row">
    <button id="lockBtn">üîì Move</button>
    <button id="gridBtn">Grid</button>
  </div>

  <hr style="opacity:.2">

  <div class="row">
    <button id="hostBtn" class="primary">Host</button>
    
  </div>

  <hr style="opacity:.2">

  <div class="row">
    <button id="saveSessionBtn">üíæ Save Session</button>
    <button id="loadSessionBtn">üìÇ Load Session</button>
  </div>

  <div class="row">
    <label>Record Mode</label>
    <select id="recordMode" style="flex: 1; padding: 8px; border-radius: 12px; background: rgba(255, 255, 255, 0.05); border: 1px solid var(--glass-light); color: white; font-size: 13px; outline: none;">
      <option value="timelapse">Timelapse</option>
      <option value="full">Full Video</option>
    </select>
  </div>

  <div class="row" id="timelapseOptions">
    <label>Interval</label>
    <div style="flex: 1; display: flex; gap: 8px; align-items: center;">
      <button id="interval1sBtn" style="flex: 0 0 auto; padding: 8px 16px; font-size: 12px;">1s</button>
      <input type="number" id="customInterval" placeholder="Custom (seconds)" min="0.1" step="0.1" value="1" style="flex: 1; padding: 8px; border-radius: 12px; background: rgba(255, 255, 255, 0.05); border: 1px solid var(--glass-light); color: white; font-size: 13px; outline: none;">
    </div>
  </div>

  <div class="row">
    <button id="recordTimelapseBtn">üé¨ Start Recording</button>
  </div>

  <div id="shareLinkContainer" class="hidden">
    <div id="shareLink">
      <input type="text" id="shareLinkInput" readonly>
      <button id="copyBtn">Copy</button>
    </div>
  </div>

  <div id="shareId"></div>
</div>

<!-- VIEWER -->
<video id="remoteVideo" autoplay playsinline muted class="hidden"></video>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script>

// ================= APP MODE =================
let appMode = "host";
let renderActive = true;

/* ================= CAMERA ================= */

function startCamera() {
  navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" } })
    .then(s => camera.srcObject = s);
}
// ========== FIRST SCREEN LOGIC ==========
const firstScreen = document.getElementById("firstScreen");
const joinScreen = document.getElementById("joinScreen");
const hostSelectBtn = document.getElementById("hostSelectBtn");
const joinSelectBtn = document.getElementById("joinSelectBtn");
const joinKeyInput = document.getElementById("joinKeyInput");
const joinKeyBtn = document.getElementById("joinKeyBtn");
const backToFirstBtn = document.getElementById("backToFirstBtn");

function showHostScreen() {
  firstScreen.classList.add("hidden");
  joinScreen.classList.add("hidden");
  backToFirstBtn.classList.add("hidden");
  camera.classList.remove("hidden");
  overlayCanvas.classList.remove("hidden");
  gridCanvas.classList.remove("hidden");
  panel.classList.remove("hidden");
  topBar.classList.remove("hidden");
  startCamera();
  // Try to load saved session from localStorage only when entering host mode
  tryLoadFromLocalStorage();
  // Don't auto-start hosting, let user click Host button
}

function showJoinScreen() {
  firstScreen.classList.add("hidden");
  joinScreen.classList.remove("hidden");
  backToFirstBtn.classList.remove("hidden");
  joinKeyInput.value = "";
  joinKeyInput.focus();
}

function doJoin() {
  const idOrLink = joinKeyInput.value.trim();
  if (!idOrLink) {
    joinKeyInput.focus();
    return;
  }
  joinScreen.classList.add("hidden");
  backToFirstBtn.classList.add("hidden");
  // Show host UI while waiting for stream
  camera.classList.remove("hidden");
  overlayCanvas.classList.remove("hidden");
  gridCanvas.classList.remove("hidden");
  panel.classList.remove("hidden");
  topBar.classList.remove("hidden");
  join(idOrLink);
}

hostSelectBtn.onclick = showHostScreen;
joinSelectBtn.onclick = showJoinScreen;
joinKeyBtn.onclick = doJoin;
joinKeyInput.addEventListener("keydown", e => { if (e.key === "Enter") doJoin(); });
backToFirstBtn.onclick = () => {
  joinScreen.classList.add("hidden");
  backToFirstBtn.classList.add("hidden");
  firstScreen.classList.remove("hidden");
};

// Panel buttons
document.getElementById("hostBtn").onclick = host;


// Hide all main UI at start
camera.classList.add("hidden");
overlayCanvas.classList.add("hidden");
gridCanvas.classList.add("hidden");
panel.classList.add("hidden");
topBar.classList.add("hidden");
backToFirstBtn.classList.add("hidden");

/* ================= CANVAS ================= */
const ctx = overlayCanvas.getContext("2d");
const gtx = gridCanvas.getContext("2d");

function resize() {
  overlayCanvas.width = gridCanvas.width = innerWidth;
  overlayCanvas.height = gridCanvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* ================= IMAGE ================= */
let img = new Image();
let sketchImg = null;
let mode = "image";

let pos = { x: innerWidth/2, y: innerHeight/2 };
let scale = 1;
let rot = 0;
let opacityVal = 0.6;

let locked = false;
let showGrid = false;

upload.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  
  // Clear any existing image first
  if (img.src && img.src.startsWith('blob:')) {
    URL.revokeObjectURL(img.src);
  }
  
  // Load new image
  const objectURL = URL.createObjectURL(file);
  img.onload = function() {
    // Ensure image is fully loaded before making sketch
    if (img.complete && img.naturalWidth > 0) {
      makeSketch();
    }
  };
  img.onerror = function() {
    alert("Error loading image. Please try a different image file.");
    upload.value = ""; // Reset file input
  };
  img.src = objectURL;
};

function makeSketch() {
  if (!img.complete || img.naturalWidth === 0) {
    // Wait for image to be fully loaded
    img.onload = makeSketch;
    return;
  }
  const c = document.createElement("canvas");
  c.width = img.width;
  c.height = img.height;
  const cx = c.getContext("2d");
  cx.drawImage(img,0,0);
  const d = cx.getImageData(0,0,c.width,c.height);
  for(let i=0;i<d.data.length;i+=4){
    const g=(d.data[i]+d.data[i+1]+d.data[i+2])/3;
    d.data[i]=d.data[i+1]=d.data[i+2]=g>150?255:0;
  }
  cx.putImageData(d,0,0);
  sketchImg = new Image();
  sketchImg.onload = function() {
    // Sketch image loaded, render will pick it up
  };
  sketchImg.src = c.toDataURL();
}

/* ================= UI ================= */
opacity.oninput = e => opacityVal = +e.target.value;
sketchBtn.onclick = () => mode = "sketch";
imageBtn.onclick = () => mode = "image";

lockBtn.onclick = () => {
  locked = !locked;
  lockBtn.textContent = locked ? "üîí Locked" : "üîì Move";
};

gridBtn.onclick = () => showGrid = !showGrid;

fullscreenBtn.onclick = () => {
  document.fullscreenElement
    ? document.exitFullscreen()
    : document.documentElement.requestFullscreen();
};

/* ================= DOUBLE TAP/CLICK UI ================= */
let lastTap = 0;
let lastTapPos = { x: 0, y: 0 };
let isDoubleTap = false;
let uiHiddenTime = 0;
let preventGestureUntil = 0;

overlayCanvas.addEventListener("touchend", (e) => {
  const now = Date.now();
  const touch = e.changedTouches[0];
  const tapX = touch.clientX;
  const tapY = touch.clientY;
  
  // Check if this is a double-tap (within 300ms and 50px distance)
  const timeDiff = now - lastTap;
  const distDiff = Math.hypot(tapX - lastTapPos.x, tapY - lastTapPos.y);
  
  if (timeDiff < 300 && distDiff < 50 && e.touches.length === 0) {
    isDoubleTap = true;
    e.preventDefault();
    e.stopPropagation();
    
    // Prevent gesture handling for a short time after double-tap
    preventGestureUntil = now + 500;
    
    // Toggle UI visibility
    const wasHidden = panel.classList.contains("hidden");
    panel.classList.toggle("hidden");
    topBar.classList.toggle("hidden");
    
    // If we just hid the UI, record the time to prevent immediate re-showing
    if (!wasHidden) {
      uiHiddenTime = now;
    }
    
    // Clear gesture state
    g = null;
    
    // Reset double-tap flag after a short delay
    setTimeout(() => {
      isDoubleTap = false;
    }, 100);
  } else {
    isDoubleTap = false;
  }
  
  lastTap = now;
  lastTapPos = { x: tapX, y: tapY };
  
  // Reset gesture state when all touches end
  if (e.touches.length === 0) {
    g = null;
  }
}, { passive: false });

// Double-click for desktop/mouse users
overlayCanvas.addEventListener("dblclick", (e) => {
  e.preventDefault();
  e.stopPropagation();
  panel.classList.toggle("hidden");
  topBar.classList.toggle("hidden");
});

/* ================= GESTURES ================= */
let g = null;
overlayCanvas.addEventListener("touchstart", e => {
  // Prevent gesture handling if we just had a double-tap or UI was recently hidden
  const now = Date.now();
  if (locked || isDoubleTap || now < preventGestureUntil || (now - uiHiddenTime < 300)) {
    g = null;
    return;
  }
  
  const t = [...e.touches];
  g = {
    startPos: { ...pos },
    startScale: scale,
    startRot: rot,
    c0: center(t),
    d0: t.length>1 ? dist(t) : 0,
    a0: t.length>1 ? ang(t) : 0
  };
});

overlayCanvas.addEventListener("touchmove", e => {
  // Prevent gesture handling if we just had a double-tap or UI was recently hidden
  const now = Date.now();
  if (locked || !g || isDoubleTap || now < preventGestureUntil || (now - uiHiddenTime < 300)) {
    if (isDoubleTap || now < preventGestureUntil) {
      e.preventDefault();
      e.stopPropagation();
    }
    return;
  }
  e.preventDefault();
  const t = [...e.touches];
  const c = center(t);
  pos.x = g.startPos.x + (c.x - g.c0.x);
  pos.y = g.startPos.y + (c.y - g.c0.y);
  if (t.length > 1) {
    scale = g.startScale * (dist(t) / g.d0);
    rot = g.startRot + (ang(t) - g.a0);
  }
},{ passive:false });


function dist(t){return Math.hypot(t[1].clientX-t[0].clientX,t[1].clientY-t[0].clientY);}
function ang(t){return Math.atan2(t[1].clientY-t[0].clientY,t[1].clientX-t[0].clientX);}
function center(t){let x=0,y=0;t.forEach(p=>{x+=p.clientX;y+=p.clientY});return{x:x/t.length,y:y/t.length};}

/* ================= MOUSE GESTURES ================= */
let mouseG = null;
let isMouseDown = false;

overlayCanvas.addEventListener("mousedown", e => {
  if (locked) return;
  isMouseDown = true;
  const startX = e.clientX;
  const startY = e.clientY;
  mouseG = {
    startPos: { ...pos },
    startScale: scale,
    startRot: rot,
    startX: startX,
    startY: startY,
    isRotating: e.shiftKey || e.button === 2, // Shift key or right mouse button for rotation
    lastAngle: 0
  };
  e.preventDefault();
});

overlayCanvas.addEventListener("mousemove", e => {
  if (locked || !mouseG || !isMouseDown) return;
  e.preventDefault();
  
  const dx = e.clientX - mouseG.startX;
  const dy = e.clientY - mouseG.startY;
  
  if (mouseG.isRotating) {
    // Rotation: calculate angle from center
    const centerX = mouseG.startPos.x;
    const centerY = mouseG.startPos.y;
    const angle1 = Math.atan2(mouseG.startY - centerY, mouseG.startX - centerX);
    const angle2 = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    const deltaAngle = angle2 - angle1;
    rot = mouseG.startRot + deltaAngle;
  } else {
    // Translation: move the image
    pos.x = mouseG.startPos.x + dx;
    pos.y = mouseG.startPos.y + dy;
  }
});

overlayCanvas.addEventListener("mouseup", e => {
  isMouseDown = false;
  mouseG = null;
});

overlayCanvas.addEventListener("mouseleave", () => {
  isMouseDown = false;
  mouseG = null;
});

// Mouse wheel for scaling
overlayCanvas.addEventListener("wheel", e => {
  if (locked) return;
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? 0.9 : 1.1; // Zoom out or zoom in
  const newScale = scale * delta;
  
  // Limit scale range
  if (newScale >= 0.1 && newScale <= 10) {
    // Scale from mouse position
    const rect = overlayCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate scale relative to mouse position
    const scaleChange = newScale / scale;
    pos.x = mouseX - (mouseX - pos.x) * scaleChange;
    pos.y = mouseY - (mouseY - pos.y) * scaleChange;
    
    scale = newScale;
  }
}, { passive: false });

// Prevent context menu on right click (for rotation)
overlayCanvas.addEventListener("contextmenu", e => {
  e.preventDefault();
});

/* ================= GRID ================= */
function drawGrid() {
  gtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
  if (!showGrid) return;
  gtx.strokeStyle = "rgba(255,255,255,.15)";
  for(let i=0;i<gridCanvas.width;i+=60){
    gtx.beginPath(); gtx.moveTo(i,0); gtx.lineTo(i,gridCanvas.height); gtx.stroke();
  }
  for(let i=0;i<gridCanvas.height;i+=60){
    gtx.beginPath(); gtx.moveTo(0,i); gtx.lineTo(gridCanvas.width,i); gtx.stroke();
  }
}

/* ================= RENDER ================= */
function render() {
  if (!renderActive) return;
  ctx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  const src = mode==="sketch" ? sketchImg : img;
  if (src && src.complete && src.naturalWidth > 0) {
    ctx.save();
    ctx.translate(pos.x,pos.y);
    ctx.rotate(rot);
    ctx.globalAlpha = opacityVal;
    ctx.drawImage(
      src,
      -src.width*scale/2,
      -src.height*scale/2,
      src.width*scale,
      src.height*scale
    );
    ctx.restore();
  }
  drawGrid();
  requestAnimationFrame(render);
}
render();

/* ================= SCREEN SHARE ================= */
let peer, call;
let hostStream = null;
let isHosting = false;
let canvasStream = null;
let canvasStreamInterval = null;
let resizeHandler = null;

// Detect if device is mobile
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
         (window.innerWidth <= 768 && 'ontouchstart' in window);
}

// Create a composite canvas stream (camera + overlay)
function createCompositeStream() {
  // Create a new canvas for compositing
  const compositeCanvas = document.createElement("canvas");
  compositeCanvas.width = overlayCanvas.width || window.innerWidth;
  compositeCanvas.height = overlayCanvas.height || window.innerHeight;
  const compositeCtx = compositeCanvas.getContext("2d");
  
  // Update canvas size if window resizes
  function updateCanvasSize() {
    compositeCanvas.width = overlayCanvas.width || window.innerWidth;
    compositeCanvas.height = overlayCanvas.height || window.innerHeight;
  }
  resizeHandler = updateCanvasSize;
  window.addEventListener("resize", resizeHandler);
  
  // Capture stream from composite canvas
  const stream = compositeCanvas.captureStream(30); // 30 FPS
  
  // Function to draw composite frame
  function drawCompositeFrame() {
    if (!isHosting || !camera.srcObject || camera.readyState !== 4) return;
    
    // Update canvas size if needed
    if (compositeCanvas.width !== overlayCanvas.width || 
        compositeCanvas.height !== overlayCanvas.height) {
      updateCanvasSize();
    }
    
    // Clear and draw camera frame
    try {
      compositeCtx.drawImage(camera, 0, 0, compositeCanvas.width, compositeCanvas.height);
      
      // Draw overlay canvas on top
      compositeCtx.drawImage(overlayCanvas, 0, 0);
      
      // Draw grid canvas on top
      compositeCtx.drawImage(gridCanvas, 0, 0);
    } catch (e) {
      // Silently handle any drawing errors
      console.warn("Error drawing composite frame:", e);
    }
  }
  
  // Wait for camera to be ready, then start capturing
  function startCapturing() {
    if (camera.readyState === 4) {
      canvasStreamInterval = setInterval(drawCompositeFrame, 33); // ~30 FPS
    } else {
      camera.addEventListener("loadedmetadata", () => {
        if (isHosting && !canvasStreamInterval) {
          canvasStreamInterval = setInterval(drawCompositeFrame, 33);
        }
      }, { once: true });
    }
  }
  
  startCapturing();
  
  return stream;
}

function stopHosting() {
  if (call) {
    call.close();
    call = null;
  }
  if (hostStream) {
    hostStream.getTracks().forEach(track => track.stop());
    hostStream = null;
  }
  if (canvasStreamInterval) {
    clearInterval(canvasStreamInterval);
    canvasStreamInterval = null;
  }
  if (canvasStream) {
    canvasStream.getTracks().forEach(track => track.stop());
    canvasStream = null;
  }
  if (resizeHandler) {
    window.removeEventListener("resize", resizeHandler);
    resizeHandler = null;
  }
  isHosting = false;
  shareId.textContent = "";
  shareId.className = "";
  document.getElementById("shareLinkContainer").classList.add("hidden");
  document.getElementById("shareLinkInput").value = "";
  
  // Re-enable host button
  const hostBtn = document.getElementById("hostBtn");
  if (hostBtn) {
    hostBtn.disabled = false;
    hostBtn.classList.remove("disabled");
  }
  
  // Stop recording if active
  if (isRecording) {
    stopRecordingTimelapse();
  }
}

function host() {
  if (isHosting) {
    alert("Already hosting. Please stop the current session first.");
    return;
  }
  
  // Clean up any existing peer
  if (peer) {
    peer.destroy();
  }
  
  // Ensure camera is started
  if (!camera.srcObject) {
    startCamera();
  }
  
  isHosting = true;
  shareId.textContent = "Starting host...";
  shareId.className = "warning";
  
  // Disable host button
  const hostBtn = document.getElementById("hostBtn");
  if (hostBtn) {
    hostBtn.disabled = true;
    hostBtn.classList.add("disabled");
  }
  
  // Generate 6-character shareable code first
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude confusing chars
  let shareCode = '';
  for (let i = 0; i < 6; i++) {
    shareCode += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  
  // Use the code as PeerJS custom ID
  peer = new Peer(shareCode, {
    debug: 2,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });
  
  peer.on("open", async (id) => {
    // id will be the shareCode we set
    const code = id;
    
    // Generate shareable link with short code
    const shareLink = `${window.location.origin}${window.location.pathname}?join=${code}`;
    const shareLinkInput = document.getElementById("shareLinkInput");
    const shareLinkContainer = document.getElementById("shareLinkContainer");
    
    shareLinkInput.value = shareLink;
    shareLinkContainer.classList.remove("hidden");
    
    shareId.textContent = `Share Code: ${code}`;
    shareId.className = "success";
    
    try {
      // Check if device is mobile or if getDisplayMedia is not available
      const isMobile = isMobileDevice();
      const hasDisplayMedia = navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia;
      
      if (isMobile || !hasDisplayMedia) {
        // For mobile devices, use canvas capture instead
        // Wait a bit for camera to be ready
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (!camera.srcObject) {
          throw new Error("Camera not available. Please ensure camera permissions are granted.");
        }
        
        // Create composite stream from canvas
        hostStream = createCompositeStream();
        canvasStream = hostStream;
        
        shareId.textContent = `Share Code: ${code} (Mobile Mode)`;
        shareId.className = "success";
        
      } else {
        // Desktop: Use screen sharing
        hostStream = await navigator.mediaDevices.getDisplayMedia({ 
          video: { 
            cursor: "always",
            displaySurface: "monitor"
          },
          audio: false 
        });
        
        // Handle when user stops sharing
        hostStream.getVideoTracks()[0].onended = () => {
          stopHosting();
        };
      }
      
    } catch (err) {
      console.error("Error getting media stream:", err);
      isHosting = false;
      shareId.textContent = "Error: Could not start sharing";
      shareId.className = "error";
      document.getElementById("shareLinkContainer").classList.add("hidden");
      
      // Re-enable host button on error
      const hostBtn = document.getElementById("hostBtn");
      if (hostBtn) {
        hostBtn.disabled = false;
        hostBtn.classList.remove("disabled");
      }
      
      if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
        alert("Permission denied. Please allow camera/screen sharing access.");
      } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
        alert("No camera found. Please ensure your device has a camera.");
      } else {
        alert("Could not start sharing: " + err.message);
      }
    }
  });
  
  peer.on("error", (err) => {
    console.error("Peer error:", err);
    shareId.textContent = "Error: " + err.message;
    shareId.className = "error";
    document.getElementById("shareLinkContainer").classList.add("hidden");
    isHosting = false;
    
    // Re-enable host button on error
    const hostBtn = document.getElementById("hostBtn");
    if (hostBtn) {
      hostBtn.disabled = false;
      hostBtn.classList.remove("disabled");
    }
  });
  
  peer.on("call", (incomingCall) => {
    if (hostStream) {
      incomingCall.answer(hostStream);
      call = incomingCall;
      
      call.on("close", () => {
        console.log("Call closed");
      });
      
      call.on("error", (err) => {
        console.error("Call error:", err);
      });
    } else {
      console.error("No stream available to answer call");
      incomingCall.close();
    }
  });
}

function join(idOrLink) {
  // Clean up any existing peer
  if (peer) {
    peer.destroy();
  }
  
  // Extract ID from link if it's a full URL
  let id = idOrLink.trim();
  if (id.includes('?join=')) {
    id = id.split('?join=')[1].split('&')[0];
  } else if (id.includes('join=')) {
    id = id.split('join=')[1].split('&')[0];
  }
  
  if (!id || id === "") {
    alert("Please enter a valid Share Code or Link");
    return;
  }
  
  shareId.textContent = "Connecting...";
  shareId.className = "warning";
  
  peer = new Peer({
    debug: 2,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });
  
  peer.on("open", () => {
    console.log("Joining with code/ID:", id);
    
    // Use the code/ID directly (if it's 6 chars, it's a custom PeerJS ID)
    const peerIdToCall = id.trim();
    
    // PeerJS requires a stream when calling, so we create a minimal dummy stream
    // We'll use a canvas-based video stream to avoid requesting camera permissions
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, 1, 1);
    
    const stream = canvas.captureStream(1); // 1 FPS is enough for a dummy stream
    
    // Small delay to ensure peer is fully ready
    setTimeout(() => {
      try {
        call = peer.call(peerIdToCall, stream);
        
        if (!call) {
          throw new Error("Could not initiate call");
        }
        
        call.on("stream", (remoteStream) => {
          console.log("Received remote stream");
          // Stop the dummy stream once we get the real stream
          stream.getTracks().forEach(track => track.stop());
          enterViewerMode(remoteStream);
        });
        
        call.on("close", () => {
          console.log("Call closed");
          stream.getTracks().forEach(track => track.stop());
          shareId.textContent = "Connection lost";
          shareId.className = "error";
          setTimeout(() => {
            alert("Connection to host lost");
            location.reload();
          }, 500);
        });
        
        call.on("error", (err) => {
          console.error("Call error:", err);
          stream.getTracks().forEach(track => track.stop());
          shareId.textContent = "Connection error";
          shareId.className = "error";
          setTimeout(() => {
            alert("Connection error: " + err.message);
            location.reload();
          }, 500);
        });
      } catch (err) {
        console.error("Error initiating call:", err);
        stream.getTracks().forEach(track => track.stop());
        shareId.textContent = "Connection failed";
        shareId.className = "error";
        setTimeout(() => {
          alert("Could not connect to host. Please check the Share ID and try again.");
          camera.classList.add("hidden");
          overlayCanvas.classList.add("hidden");
          gridCanvas.classList.add("hidden");
          panel.classList.add("hidden");
          topBar.classList.add("hidden");
          joinScreen.classList.remove("hidden");
        }, 500);
      }
    }, 100);
  });
  
  peer.on("error", (err) => {
    console.error("Peer error:", err);
    shareId.textContent = "Connection error";
    shareId.className = "error";
    setTimeout(() => {
      alert("Connection error: " + err.message);
      camera.classList.add("hidden");
      overlayCanvas.classList.add("hidden");
      gridCanvas.classList.add("hidden");
      panel.classList.add("hidden");
      topBar.classList.add("hidden");
      joinScreen.classList.remove("hidden");
    }, 500);
  });
}

function enterViewerMode(stream) {
  appMode = "viewer";
  renderActive = false;

  if (camera.srcObject) {
    camera.srcObject.getTracks().forEach(t => t.stop());
    camera.srcObject = null;
  }

  panel.classList.add("hidden");
  topBar.classList.add("hidden");
  overlayCanvas.classList.add("hidden");
  gridCanvas.classList.add("hidden");

  remoteVideo.srcObject = stream;
  remoteVideo.muted = true;
  remoteVideo.play();
  remoteVideo.classList.remove("hidden");
  
  shareId.textContent = "Connected to host";
  shareId.className = "success";
}



// ================= COPY TO CLIPBOARD =================
const copyBtn = document.getElementById("copyBtn");
const shareLinkInput = document.getElementById("shareLinkInput");

copyBtn.addEventListener("click", async () => {
  try {
    await navigator.clipboard.writeText(shareLinkInput.value);
    const originalText = copyBtn.textContent;
    copyBtn.textContent = "‚úì Copied!";
    copyBtn.classList.add("copied");
    
    setTimeout(() => {
      copyBtn.textContent = originalText;
      copyBtn.classList.remove("copied");
    }, 2000);
  } catch (err) {
    // Fallback for older browsers
    shareLinkInput.select();
    document.execCommand("copy");
    const originalText = copyBtn.textContent;
    copyBtn.textContent = "‚úì Copied!";
    copyBtn.classList.add("copied");
    
    setTimeout(() => {
      copyBtn.textContent = originalText;
      copyBtn.classList.remove("copied");
    }, 2000);
  }
});

// ================= SESSION SAVE/LOAD =================
let mediaRecorder = null;
let recordedChunks = [];
let isRecording = false;
let recordingStream = null;
let recordingCompositeCanvas = null;
let recordingCompositeCtx = null;
let recordingInterval = null;
let recordingMode = "timelapse"; // "timelapse" or "full"
let recordingIntervalSeconds = 1; // Interval in seconds for timelapse
let timelapseFrames = []; // Store frames for timelapse
let timelapseCaptureInterval = null;

// Save current session state
function saveSession() {
  if (!img.src) {
    alert("No image loaded to save.");
    return;
  }
  
  const sessionData = {
    imageData: img.src,
    sketchImageData: sketchImg ? sketchImg.src : null,
    position: { x: pos.x, y: pos.y },
    scale: scale,
    rotation: rot,
    opacity: opacityVal,
    mode: mode,
    locked: locked,
    showGrid: showGrid,
    timestamp: new Date().toISOString()
  };
  
  // Save to localStorage
  try {
    localStorage.setItem('muraly_session', JSON.stringify(sessionData));
    
    // Also create downloadable file
    const dataStr = JSON.stringify(sessionData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `muraly_session_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    link.click();
    URL.revokeObjectURL(url);
    
    shareId.textContent = "Session saved successfully!";
    shareId.className = "success";
    setTimeout(() => {
      shareId.textContent = "";
      shareId.className = "";
    }, 3000);
  } catch (err) {
    console.error("Error saving session:", err);
    alert("Error saving session: " + err.message);
  }
}

// Load saved session
function loadSession() {
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'application/json';
  fileInput.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const sessionData = JSON.parse(event.target.result);
        
        // Load image
        if (sessionData.imageData) {
          img.src = sessionData.imageData;
          img.onload = () => {
            if (sessionData.sketchImageData) {
              sketchImg = new Image();
              sketchImg.src = sessionData.sketchImageData;
            } else {
              makeSketch();
            }
            
            // Restore state
            pos.x = sessionData.position.x;
            pos.y = sessionData.position.y;
            scale = sessionData.scale || 1;
            rot = sessionData.rotation || 0;
            opacityVal = sessionData.opacity || 0.6;
            mode = sessionData.mode || "image";
            locked = sessionData.locked || false;
            showGrid = sessionData.showGrid || false;
            
            // Update UI
            opacity.value = opacityVal;
            lockBtn.textContent = locked ? "üîí Locked" : "üîì Move";
            
            shareId.textContent = "Session loaded successfully!";
            shareId.className = "success";
            setTimeout(() => {
              shareId.textContent = "";
              shareId.className = "";
            }, 3000);
          };
        }
      } catch (err) {
        console.error("Error loading session:", err);
        alert("Error loading session: " + err.message);
      }
    };
    reader.readAsText(file);
  };
  fileInput.click();
}

// Try to load from localStorage on page load
function tryLoadFromLocalStorage() {
  try {
    const saved = localStorage.getItem('muraly_session');
    if (saved) {
      const sessionData = JSON.parse(saved);
      if (sessionData.imageData) {
        img.src = sessionData.imageData;
        img.onload = () => {
          if (sessionData.sketchImageData) {
            sketchImg = new Image();
            sketchImg.src = sessionData.sketchImageData;
          } else {
            makeSketch();
          }
          
          pos.x = sessionData.position.x;
          pos.y = sessionData.position.y;
          scale = sessionData.scale || 1;
          rot = sessionData.rotation || 0;
          opacityVal = sessionData.opacity || 0.6;
          mode = sessionData.mode || "image";
          locked = sessionData.locked || false;
          showGrid = sessionData.showGrid || false;
          
          opacity.value = opacityVal;
          lockBtn.textContent = locked ? "üîí Locked" : "üîì Move";
        };
      }
    }
  } catch (err) {
    console.warn("Could not load from localStorage:", err);
  }
}

// Create recording canvas and stream
function createRecordingStream() {
  if (recordingCompositeCanvas) {
    return recordingCompositeCanvas.captureStream(30);
  }
  
  recordingCompositeCanvas = document.createElement("canvas");
  recordingCompositeCanvas.width = overlayCanvas.width || window.innerWidth;
  recordingCompositeCanvas.height = overlayCanvas.height || window.innerHeight;
  recordingCompositeCtx = recordingCompositeCanvas.getContext("2d");
  
  // Update canvas size if window resizes
  function updateRecordingCanvasSize() {
    recordingCompositeCanvas.width = overlayCanvas.width || window.innerWidth;
    recordingCompositeCanvas.height = overlayCanvas.height || window.innerHeight;
  }
  window.addEventListener("resize", updateRecordingCanvasSize);
  
  return recordingCompositeCanvas.captureStream(30);
}

// Start recording (timelapse or full video)
function startRecordingTimelapse() {
  if (isRecording) {
    stopRecordingTimelapse();
    return;
  }
  
  if (!camera.srcObject || camera.readyState !== 4) {
    alert("Camera not ready. Please ensure camera is active.");
    return;
  }
  
  if (!img.src) {
    alert("No image loaded. Please upload an image first.");
    return;
  }
  
  // Get recording mode and interval
  const recordModeSelect = document.getElementById("recordMode");
  recordingMode = recordModeSelect ? recordModeSelect.value : "timelapse";
  
  if (recordingMode === "timelapse") {
    const customIntervalInput = document.getElementById("customInterval");
    recordingIntervalSeconds = customIntervalInput ? parseFloat(customIntervalInput.value) || 1 : 1;
    
    if (recordingIntervalSeconds < 0.1) {
      alert("Interval must be at least 0.1 seconds.");
      return;
    }
  }
  
  try {
    if (recordingMode === "full") {
      // Full video recording - continuous
      startFullVideoRecording();
    } else {
      // Timelapse recording - capture frames at intervals
      startTimelapseRecording();
    }
  } catch (err) {
    console.error("Error starting recording:", err);
    alert("Error starting recording: " + err.message);
  }
}

// Start full video recording (continuous)
function startFullVideoRecording() {
  recordingStream = createRecordingStream();
  
  // Check for MediaRecorder support
  if (!window.MediaRecorder) {
    alert("MediaRecorder API not supported in this browser.");
    return;
  }
  
  // Get available MIME types
  const options = { mimeType: 'video/webm;codecs=vp9' };
  if (!MediaRecorder.isTypeSupported(options.mimeType)) {
    options.mimeType = 'video/webm;codecs=vp8';
    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
      options.mimeType = 'video/webm';
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        options.mimeType = 'video/mp4';
      }
    }
  }
  
  mediaRecorder = new MediaRecorder(recordingStream, {
    ...options,
    videoBitsPerSecond: 5000000 // High quality: 5 Mbps
  });
  
  recordedChunks = [];
  
  mediaRecorder.ondataavailable = (event) => {
    if (event.data && event.data.size > 0) {
      recordedChunks.push(event.data);
    }
  };
  
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: options.mimeType || 'video/webm' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    link.download = `muraly_video_${timestamp}.${options.mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
    link.click();
    URL.revokeObjectURL(url);
    
    recordedChunks = [];
    
    shareId.textContent = "Video saved!";
    shareId.className = "success";
    setTimeout(() => {
      shareId.textContent = "";
      shareId.className = "";
    }, 3000);
  };
  
  mediaRecorder.onerror = (event) => {
    console.error("MediaRecorder error:", event);
    alert("Error recording: " + event.error);
    stopRecordingTimelapse();
  };
  
  // Start recording
  mediaRecorder.start(1000); // Collect data every second
  
  // Draw frames to recording canvas continuously
  function drawRecordingFrame() {
    if (!isRecording || !camera.srcObject || camera.readyState !== 4) return;
    
    try {
      // Update canvas size if needed
      if (recordingCompositeCanvas.width !== overlayCanvas.width || 
          recordingCompositeCanvas.height !== overlayCanvas.height) {
        recordingCompositeCanvas.width = overlayCanvas.width || window.innerWidth;
        recordingCompositeCanvas.height = overlayCanvas.height || window.innerHeight;
      }
      
      // Draw camera frame
      recordingCompositeCtx.drawImage(camera, 0, 0, recordingCompositeCanvas.width, recordingCompositeCanvas.height);
      
      // Draw overlay canvas on top
      recordingCompositeCtx.drawImage(overlayCanvas, 0, 0);
      
      // Draw grid canvas on top
      recordingCompositeCtx.drawImage(gridCanvas, 0, 0);
    } catch (e) {
      console.warn("Error drawing recording frame:", e);
    }
  }
  
  recordingInterval = setInterval(drawRecordingFrame, 33); // ~30 FPS
  
  isRecording = true;
  const recordBtn = document.getElementById("recordTimelapseBtn");
  if (recordBtn) {
    recordBtn.textContent = "‚èπ Stop Recording";
    recordBtn.classList.add("danger");
  }
  
  shareId.textContent = "Recording video...";
  shareId.className = "warning";
}

// Start timelapse recording (capture frames at intervals)
function startTimelapseRecording() {
  timelapseFrames = [];
  
  // Create canvas for capturing frames
  if (!recordingCompositeCanvas) {
    recordingCompositeCanvas = document.createElement("canvas");
    recordingCompositeCanvas.width = overlayCanvas.width || window.innerWidth;
    recordingCompositeCanvas.height = overlayCanvas.height || window.innerHeight;
    recordingCompositeCtx = recordingCompositeCanvas.getContext("2d");
  }
  
  // Function to capture a frame
  function captureFrame() {
    if (!isRecording || !camera.srcObject || camera.readyState !== 4) return;
    
    try {
      // Update canvas size if needed
      if (recordingCompositeCanvas.width !== overlayCanvas.width || 
          recordingCompositeCanvas.height !== overlayCanvas.height) {
        recordingCompositeCanvas.width = overlayCanvas.width || window.innerWidth;
        recordingCompositeCanvas.height = overlayCanvas.height || window.innerHeight;
      }
      
      // Draw camera frame
      recordingCompositeCtx.drawImage(camera, 0, 0, recordingCompositeCanvas.width, recordingCompositeCanvas.height);
      
      // Draw overlay canvas on top
      recordingCompositeCtx.drawImage(overlayCanvas, 0, 0);
      
      // Draw grid canvas on top
      recordingCompositeCtx.drawImage(gridCanvas, 0, 0);
      
      // Capture frame as image data
      const frameData = recordingCompositeCanvas.toDataURL('image/png');
      timelapseFrames.push(frameData);
      
      // Update status
      shareId.textContent = `Recording timelapse... (${timelapseFrames.length} frames)`;
      shareId.className = "warning";
    } catch (e) {
      console.warn("Error capturing frame:", e);
    }
  }
  
  // Capture first frame immediately
  captureFrame();
  
  // Capture frames at specified interval
  const intervalMs = recordingIntervalSeconds * 1000;
  timelapseCaptureInterval = setInterval(captureFrame, intervalMs);
  
  isRecording = true;
  const recordBtn = document.getElementById("recordTimelapseBtn");
  if (recordBtn) {
    recordBtn.textContent = "‚èπ Stop Recording";
    recordBtn.classList.add("danger");
  }
  
  shareId.textContent = `Recording timelapse (${recordingIntervalSeconds}s interval)...`;
  shareId.className = "warning";
}

// Stop recording timelapse
function stopRecordingTimelapse() {
  if (!isRecording) return;
  
  isRecording = false;
  
  if (recordingMode === "full") {
    // Stop full video recording
    if (recordingInterval) {
      clearInterval(recordingInterval);
      recordingInterval = null;
    }
    
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }
    
    if (recordingStream) {
      recordingStream.getTracks().forEach(track => track.stop());
      recordingStream = null;
    }
  } else {
    // Stop timelapse recording and compile frames
    if (timelapseCaptureInterval) {
      clearInterval(timelapseCaptureInterval);
      timelapseCaptureInterval = null;
    }
    
    if (timelapseFrames.length === 0) {
      shareId.textContent = "No frames captured";
      shareId.className = "error";
      const recordBtn = document.getElementById("recordTimelapseBtn");
      if (recordBtn) {
        recordBtn.textContent = "üé¨ Start Recording";
        recordBtn.classList.remove("danger");
      }
      return;
    }
    
    shareId.textContent = `Processing ${timelapseFrames.length} frames...`;
    shareId.className = "warning";
    
    // Compile timelapse frames into video
    compileTimelapseVideo();
  }
  
  const recordBtn = document.getElementById("recordTimelapseBtn");
  if (recordBtn) {
    recordBtn.textContent = "üé¨ Start Recording";
    recordBtn.classList.remove("danger");
  }
}

// Compile timelapse frames into a video
function compileTimelapseVideo() {
  if (timelapseFrames.length === 0) return;
  
  // Create a canvas for video frames
  const videoCanvas = document.createElement("canvas");
  videoCanvas.width = recordingCompositeCanvas.width;
  videoCanvas.height = recordingCompositeCanvas.height;
  const videoCtx = videoCanvas.getContext("2d");
  
  // Create stream from canvas
  const stream = videoCanvas.captureStream(30); // 30 FPS output
  
  // Check for MediaRecorder support
  if (!window.MediaRecorder) {
    alert("MediaRecorder API not supported in this browser.");
    return;
  }
  
  // Get available MIME types
  const options = { mimeType: 'video/webm;codecs=vp9' };
  if (!MediaRecorder.isTypeSupported(options.mimeType)) {
    options.mimeType = 'video/webm;codecs=vp8';
    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
      options.mimeType = 'video/webm';
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        options.mimeType = 'video/mp4';
      }
    }
  }
  
  mediaRecorder = new MediaRecorder(stream, {
    ...options,
    videoBitsPerSecond: 5000000 // High quality: 5 Mbps
  });
  
  recordedChunks = [];
  
  mediaRecorder.ondataavailable = (event) => {
    if (event.data && event.data.size > 0) {
      recordedChunks.push(event.data);
    }
  };
  
  const totalFrames = timelapseFrames.length;
  
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: options.mimeType || 'video/webm' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    link.download = `muraly_timelapse_${timestamp}.${options.mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
    link.click();
    URL.revokeObjectURL(url);
    
    recordedChunks = [];
    timelapseFrames = [];
    
    shareId.textContent = `Timelapse video saved! (${totalFrames} frames)`;
    shareId.className = "success";
    setTimeout(() => {
      shareId.textContent = "";
      shareId.className = "";
    }, 3000);
  };
  
  mediaRecorder.onerror = (event) => {
    console.error("MediaRecorder error:", event);
    alert("Error compiling video: " + event.error);
    timelapseFrames = [];
  };
  
  // Start recording
  mediaRecorder.start();
  
  // Draw frames to canvas at 30 FPS
  let frameIndex = 0;
  const frameDuration = 1000 / 30; // ~33ms per frame at 30 FPS
  
  function drawNextFrame() {
    if (frameIndex >= timelapseFrames.length) {
      mediaRecorder.stop();
      stream.getTracks().forEach(track => track.stop());
      return;
    }
    
    // Load and draw frame
    const img = new Image();
    img.onload = () => {
      videoCtx.drawImage(img, 0, 0, videoCanvas.width, videoCanvas.height);
      frameIndex++;
      
      // Continue to next frame
      setTimeout(drawNextFrame, frameDuration);
    };
    img.onerror = () => {
      frameIndex++;
      setTimeout(drawNextFrame, frameDuration);
    };
    img.src = timelapseFrames[frameIndex];
  }
  
  // Start drawing frames
  drawNextFrame();
}

// Event listeners for save/load/record buttons
document.getElementById("saveSessionBtn").onclick = saveSession;
document.getElementById("loadSessionBtn").onclick = loadSession;
document.getElementById("recordTimelapseBtn").onclick = startRecordingTimelapse;

// Event listeners for recording mode and interval
const recordModeSelect = document.getElementById("recordMode");
const timelapseOptions = document.getElementById("timelapseOptions");
const interval1sBtn = document.getElementById("interval1sBtn");
const customIntervalInput = document.getElementById("customInterval");

// Show/hide timelapse options based on mode
if (recordModeSelect) {
  recordModeSelect.addEventListener("change", (e) => {
    recordingMode = e.target.value;
    if (timelapseOptions) {
      timelapseOptions.style.display = recordingMode === "timelapse" ? "flex" : "none";
    }
  });
  
  // Initialize visibility
  if (timelapseOptions) {
    timelapseOptions.style.display = recordingMode === "timelapse" ? "flex" : "none";
  }
}

// 1 second interval button
if (interval1sBtn) {
  interval1sBtn.onclick = () => {
    if (customIntervalInput) {
      customIntervalInput.value = "1";
      recordingIntervalSeconds = 1;
    }
  };
}

// Custom interval input
if (customIntervalInput) {
  customIntervalInput.addEventListener("input", (e) => {
    const value = parseFloat(e.target.value);
    if (!isNaN(value) && value >= 0.1) {
      recordingIntervalSeconds = value;
    }
  });
  
  customIntervalInput.addEventListener("change", (e) => {
    const value = parseFloat(e.target.value);
    if (isNaN(value) || value < 0.1) {
      e.target.value = "1";
      recordingIntervalSeconds = 1;
    }
  });
}

// Cleanup on page unload
window.addEventListener("beforeunload", () => {
  if (isRecording) {
    stopRecordingTimelapse();
  }
});

// ================= CHECK URL PARAMETERS =================
window.addEventListener("DOMContentLoaded", () => {
  const urlParams = new URLSearchParams(window.location.search);
  const joinId = urlParams.get("join");
  
  if (joinId) {
    // Automatically join if join parameter is in URL
    firstScreen.classList.add("hidden");
    joinScreen.classList.add("hidden");
    camera.classList.remove("hidden");
    overlayCanvas.classList.remove("hidden");
    gridCanvas.classList.remove("hidden");
    panel.classList.remove("hidden");
    topBar.classList.remove("hidden");
    join(joinId);
  }
  // Don't auto-load from localStorage on page load - only when user enters host mode
});

// Clean up code mappings when page unloads
window.addEventListener("beforeunload", () => {
  codeToPeerIdMap = {};
  peerIdToCodeMap = {};
});

// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('Service Worker registered:', registration);
      })
      .catch((error) => {
        console.log('Service Worker registration failed:', error);
      });
  });
}
</script>

</body>
</html>
